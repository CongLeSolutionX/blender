/* SPDX-FileCopyrightText: 2024 Tenkai Raiko
 *
 * SPDX-License-Identifier: Apache-2.0 */

#include "node_hash.h"
#include "node_math.h"
#include "node_noise.h"
#include "stdcycles.h"
#include "vector2.h"
#include "vector4.h"

#define vector3 point

#define ASSIGN_REMAP_INPUTS(X, A, B, C, D, E, F) \
  remap[A] = StepCenter##X; \
  remap[B] = StepWidth##X; \
  remap[C] = StepValue##X; \
  remap[D] = EllipseHeight##X; \
  remap[E] = EllipseWidth##X; \
  remap[F] = InflectionPoint##X; \
  if (StepCenterRandomness##X != 0.0) { \
    remap_min[index_count] = max(remap[A] - StepCenterRandomness##X, 0.0); \
    remap_max[index_count] = max(remap[A] + StepCenterRandomness##X, 0.0); \
    remap_index_list[index_count] = A; \
    ++index_count; \
  } \
  if (StepWidthRandomness##X != 0.0) { \
    remap_min[index_count] = max(remap[B] - StepWidthRandomness##X, 0.0); \
    remap_max[index_count] = max(remap[B] + StepWidthRandomness##X, 0.0); \
    remap_index_list[index_count] = B; \
    ++index_count; \
  } \
  if (StepValueRandomness##X != 0.0) { \
    remap_min[index_count] = remap[C] - StepValueRandomness##X; \
    remap_max[index_count] = remap[C] + StepValueRandomness##X; \
    remap_index_list[index_count] = C; \
    ++index_count; \
  } \
  if (EllipseHeightRandomness##X != 0.0) { \
    remap_min[index_count] = clamp(remap[D] - EllipseHeightRandomness##X, 0.0, 1.0); \
    remap_max[index_count] = clamp(remap[D] + EllipseHeightRandomness##X, 0.0, 1.0); \
    remap_index_list[index_count] = D; \
    ++index_count; \
  } \
  if (EllipseWidthRandomness##X != 0.0) { \
    remap_min[index_count] = clamp(remap[E] - EllipseWidthRandomness##X, 0.0, 1.0); \
    remap_max[index_count] = clamp(remap[E] + EllipseWidthRandomness##X, 0.0, 1.0); \
    remap_index_list[index_count] = E; \
    ++index_count; \
  } \
  if (InflectionPointRandomness##X != 0.0) { \
    remap_min[index_count] = clamp(remap[F] - InflectionPointRandomness##X, 0.0, 1.0); \
    remap_max[index_count] = clamp(remap[F] + InflectionPointRandomness##X, 0.0, 1.0); \
    remap_index_list[index_count] = F; \
    ++index_count; \
  }

struct DeterministicVariables {
  string mode;
  int normalize_r_gon_parameter;
  vector4 coord;
  float scale;
  float smoothness;
  float accuracy;
  int integer_sides;
  int elliptical_corners;
  int invert_order_of_transformation;
  int transform_fields_noise;
  int transform_coordinates_noise;
  int uniform_scale_randomness;
  float noise_fragmentation;
  float noise_fields_strength_1;
  float noise_coordinates_strength_1;
  float noise_scale_1;
  float noise_detail_1;
  float noise_roughness_1;
  float noise_lacunarity_1;
  float noise_fields_strength_2;
  float noise_coordinates_strength_2;
  float noise_scale_2;
  float noise_detail_2;
  float noise_roughness_2;
  float noise_lacunarity_2;
  string grid_dimensions;
  vector4 grid_vector_1;
  vector4 grid_vector_2;
  vector4 grid_vector_3;
  vector4 grid_vector_4;
  string step_count;

  int calculate_r_sphere_field;
  int calculate_r_gon_parameter_field;
  int calculate_max_unit_parameter_field;
  int calculate_coordinates_outputs;

  int smoothness_non_zero;
  int noise_fragmentation_non_zero;
  int calculate_fields_noise_1;
  int calculate_fields_noise_2;
  int calculate_coordinates_noise_1;
  int calculate_coordinates_noise_2;
};

struct OutVariables {
  float out_r_sphere_field;
  float r_gon_parameter_field;
  float max_unit_parameter_field;
  float segment_id_field;
  vector4 out_index_field;
  vector4 out_position_field;
  vector4 out_r_sphere_coordinates;
};

/* Fast Cramer Coefficients of the 3x3 matrix M. */
struct Fcc_3x3 {
  /* Determinant of the 3x3 matrix M. */
  float M_det;
  /* Determinant of the 2x2 submatrices M_i_j. The first index i denotes the row, the second index
   * j the coloumn being removed from M. */
  float M_1_1_det;
  float M_2_1_det;
  float M_3_1_det;
};

/* Fast Cramer Coefficients of the 4x4 matrix M. */
struct Fcc_4x4 {
  /* Determinant of the 4x4 matrix M. */
  float M_det;
  /* Fast Cramer Coefficients of the 3x3 submatrices M_i_j. The first index i denotes the row, the
   * second index j the coloumn being removed from M. */
  Fcc_3x3 M_1_1_fcc;
  Fcc_3x3 M_2_1_fcc;
  Fcc_3x3 M_3_1_fcc;
  Fcc_3x3 M_4_1_fcc;
};

Fcc_3x3 calculate_Fcc_3x3(vector3 a_1, vector3 a_2, vector3 a_3)
{
  Fcc_3x3 A_fcc;

  A_fcc.M_1_1_det = a_2.y * a_3.z - a_3.y * a_2.z;
  A_fcc.M_2_1_det = a_2.x * a_3.z - a_3.x * a_2.z;
  A_fcc.M_3_1_det = a_2.x * a_3.y - a_3.x * a_2.y;

  A_fcc.M_det = a_1.x * A_fcc.M_1_1_det - a_1.y * A_fcc.M_2_1_det + a_1.z * A_fcc.M_3_1_det;

  return A_fcc;
}

Fcc_4x4 calculate_Fcc_4x4(vector4 a_1, vector4 a_2, vector4 a_3, vector4 a_4)
{
  Fcc_4x4 A_fcc;

  A_fcc.M_1_1_fcc = calculate_Fcc_3x3(
      vector3(a_2.y, a_2.z, a_2.w), vector3(a_3.y, a_3.z, a_3.w), vector3(a_4.y, a_4.z, a_4.w));
  A_fcc.M_2_1_fcc = calculate_Fcc_3x3(
      vector3(a_2.x, a_2.z, a_2.w), vector3(a_3.x, a_3.z, a_3.w), vector3(a_4.x, a_4.z, a_4.w));
  A_fcc.M_3_1_fcc = calculate_Fcc_3x3(
      vector3(a_2.x, a_2.y, a_2.w), vector3(a_3.x, a_3.y, a_3.w), vector3(a_4.x, a_4.y, a_4.w));
  A_fcc.M_4_1_fcc = calculate_Fcc_3x3(
      vector3(a_2.x, a_2.y, a_2.z), vector3(a_3.x, a_3.y, a_3.z), vector3(a_4.x, a_4.y, a_4.z));

  A_fcc.M_det = a_1.x * A_fcc.M_1_1_fcc.M_det - a_1.y * A_fcc.M_2_1_fcc.M_det +
                a_1.z * A_fcc.M_3_1_fcc.M_det - a_1.w * A_fcc.M_4_1_fcc.M_det;

  return A_fcc;
}

/* Solves Ax=b for x using the Fast Cramer algorithm, with a_n being the nth coloumn vector of the
 * invertible 2x2 matrix A. fc_linear_system_solve_non_singular_4x4 doesn't check whether or not A
 * is invertible. Calling it on a singular matrix leads to division by 0. */
vector2 fc_linear_system_solve_non_singular_2x2(vector2 a_1, vector2 a_2, vector2 b, float M_det)
{
  /* Use Cramer's rule on both components instead of further recursion because it is faster. */
  return vector2((b.x * a_2.y - a_2.x * b.y) / M_det, (a_1.x * b.y - b.x * a_1.y) / M_det);
}

/* Solves Ax=b for x using the Fast Cramer algorithm, with a_n being the nth coloumn vector of the
 * invertible 3x3 matrix A. fc_linear_system_solve_non_singular_4x4 doesn't check whether or not A
 * is invertible. Calling it on a singular matrix leads to division by 0. */
vector3 fc_linear_system_solve_non_singular_3x3(
    vector3 a_1, vector3 a_2, vector3 a_3, vector3 b, Fcc_3x3 A_fcc)
{
  float solution_x = (b.x * A_fcc.M_1_1_det - b.y * A_fcc.M_2_1_det + b.z * A_fcc.M_3_1_det) /
                     A_fcc.M_det;

  if (A_fcc.M_1_1_det != 0.0) {
    vector2 solution_yz = fc_linear_system_solve_non_singular_2x2(
        vector2(a_2.y, a_2.z),
        vector2(a_3.y, a_3.z),
        vector2(b.y - a_1.y * solution_x, b.z - a_1.z * solution_x),
        A_fcc.M_1_1_det);
    return vector3(solution_x, solution_yz.x, solution_yz.y);
  }
  else if (A_fcc.M_2_1_det != 0.0) {
    vector2 solution_yz = fc_linear_system_solve_non_singular_2x2(
        vector2(a_2.x, a_2.z),
        vector2(a_3.x, a_3.z),
        vector2(b.x - a_1.x * solution_x, b.z - a_1.z * solution_x),
        A_fcc.M_2_1_det);
    return vector3(solution_x, solution_yz.x, solution_yz.y);
  }
  else {
    vector2 solution_yz = fc_linear_system_solve_non_singular_2x2(
        vector2(a_2.x, a_2.y),
        vector2(a_3.x, a_3.y),
        vector2(b.x - a_1.x * solution_x, b.y - a_1.y * solution_x),
        A_fcc.M_3_1_det);
    return vector3(solution_x, solution_yz.x, solution_yz.y);
  }
}

/* Solves Ax=b for x using the Fast Cramer algorithm, with a_n being the nth coloumn vector of the
 * invertible 4x4 matrix A. fc_linear_system_solve_non_singular_4x4 doesn't check whether or not A
 * is invertible. Calling it on a singular matrix leads to division by 0. */
vector4 fc_linear_system_solve_non_singular_4x4(
    vector4 a_1, vector4 a_2, vector4 a_3, vector4 a_4, vector4 b, Fcc_4x4 A_fcc)
{
  float solution_x = (b.x * A_fcc.M_1_1_fcc.M_det - b.y * A_fcc.M_2_1_fcc.M_det +
                      b.z * A_fcc.M_3_1_fcc.M_det - b.w * A_fcc.M_4_1_fcc.M_det) /
                     A_fcc.M_det;

  if (A_fcc.M_1_1_fcc.M_det != 0.0) {
    vector3 solution_yzw = fc_linear_system_solve_non_singular_3x3(
        vector3(a_2.y, a_2.z, a_2.w),
        vector3(a_3.y, a_3.z, a_3.w),
        vector3(a_4.y, a_4.z, a_4.w),
        vector3(b.y - a_1.y * solution_x, b.z - a_1.z * solution_x, b.w - a_1.w * solution_x),
        A_fcc.M_1_1_fcc);
    return vector4(solution_x, solution_yzw.x, solution_yzw.y, solution_yzw.z);
  }
  else if (A_fcc.M_2_1_fcc.M_det != 0.0) {
    vector3 solution_yzw = fc_linear_system_solve_non_singular_3x3(
        vector3(a_2.x, a_2.z, a_2.w),
        vector3(a_3.x, a_3.z, a_3.w),
        vector3(a_4.x, a_4.z, a_4.w),
        vector3(b.x - a_1.x * solution_x, b.z - a_1.z * solution_x, b.w - a_1.w * solution_x),
        A_fcc.M_2_1_fcc);
    return vector4(solution_x, solution_yzw.x, solution_yzw.y, solution_yzw.z);
  }
  else if (A_fcc.M_3_1_fcc.M_det != 0.0) {
    vector3 solution_yzw = fc_linear_system_solve_non_singular_3x3(
        vector3(a_2.x, a_2.y, a_2.w),
        vector3(a_3.x, a_3.y, a_3.w),
        vector3(a_4.x, a_4.y, a_4.w),
        vector3(b.x - a_1.x * solution_x, b.y - a_1.y * solution_x, b.w - a_1.w * solution_x),
        A_fcc.M_3_1_fcc);
    return vector4(solution_x, solution_yzw.x, solution_yzw.y, solution_yzw.z);
  }
  else {
    vector3 solution_yzw = fc_linear_system_solve_non_singular_3x3(
        vector3(a_2.x, a_2.y, a_2.z),
        vector3(a_3.x, a_3.y, a_3.z),
        vector3(a_4.x, a_4.y, a_4.z),
        vector3(b.x - a_1.x * solution_x, b.y - a_1.y * solution_x, b.z - a_1.z * solution_x),
        A_fcc.M_4_1_fcc);
    return vector4(solution_x, solution_yzw.x, solution_yzw.y, solution_yzw.z);
  }
}

float chebychev_norm(float coord)
{
  return abs(coord);
}

float chebychev_norm(vector2 coord)
{
  return max(abs(coord.x), abs(coord.y));
}

float chebychev_norm(vector3 coord)
{
  return max(abs(coord.x), max(abs(coord.y), abs(coord.z)));
}

float p_norm(float coord)
{
  return abs(coord);
}

float p_norm(vector2 coord, float exponent)
{
  /* Use Chebychev norm instead of p-norm for high exponent values to avoid going out of the
   * floating point representable range. */
  return (exponent > 32.0) ?
             chebychev_norm(coord) :
             pow(pow(abs(coord.x), exponent) + pow(abs(coord.y), exponent), 1.0 / exponent);
}

float p_norm(vector3 coord, float exponent)
{
  /* Use Chebychev norm instead of p-norm for high exponent values to avoid going out of the
   * floating point representable range. */
  return (exponent > 32.0) ? chebychev_norm(coord) :
                             pow(pow(abs(coord.x), exponent) + pow(abs(coord.y), exponent) +
                                     pow(abs(coord.z), exponent),
                                 1.0 / exponent);
}

float euclidean_norm(vector4 coord)
{
  return sqrt(square(coord.x) + square(coord.y) + square(coord.z) + square(coord.w));
}

float calculate_l_angle_bisector_2d_full_roundness_irregular_elliptical(float r_gon_sides,
                                                                        vector2 coord,
                                                                        float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;

  if ((x_axis_A_coord >= ref_A_angle_bisector) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - ref_A_angle_bisector))
  {
    return l_projection_2d;
  }
  else {
    /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
     * to avoid a case distinction. */
    float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_angle_bisector) &&
        (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
    {
      nearest_ref_MSA_coord += last_ref_A_x_axis;
      nearest_ref_MSA_coord *= -1;
    }
    float l_basis_vector_1 = tan(ref_A_angle_bisector);
    /* When the fractional part of r_gon_sides is very small division by l_basis_vector_2 causes
     * precision issues. Change to double if necessary */
    float l_basis_vector_2 = sin(last_angle_bisector_A_x_axis) *
                             sqrt(square(tan(ref_A_angle_bisector)) + 1.0);
    vector2 ellipse_center =
        vector2(cos(ref_A_angle_bisector) / cos(ref_A_angle_bisector - ref_A_angle_bisector),
                sin(ref_A_angle_bisector) / cos(ref_A_angle_bisector - ref_A_angle_bisector)) -
        l_basis_vector_2 *
            vector2(sin(last_angle_bisector_A_x_axis), cos(last_angle_bisector_A_x_axis));
    vector2 transformed_direction_vector = vector2(
        cos(last_angle_bisector_A_x_axis + nearest_ref_MSA_coord) /
            (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
        cos(ref_A_angle_bisector - nearest_ref_MSA_coord) /
            (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
    vector2 transformed_origin = vector2(
        (ellipse_center.y * sin(last_angle_bisector_A_x_axis) -
         ellipse_center.x * cos(last_angle_bisector_A_x_axis)) /
            (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
        -(ellipse_center.y * sin(ref_A_angle_bisector) +
          ellipse_center.x * cos(ref_A_angle_bisector)) /
            (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
    float l_coord_R_l_angle_bisector_2d =
        (-(transformed_direction_vector.x * transformed_origin.x +
           transformed_direction_vector.y * transformed_origin.y) +
         sqrt(square(transformed_direction_vector.x * transformed_origin.x +
                     transformed_direction_vector.y * transformed_origin.y) -
              (square(transformed_direction_vector.x) + square(transformed_direction_vector.y)) *
                  (square(transformed_origin.x) + square(transformed_origin.y) - 1.0))) /
        (square(transformed_direction_vector.x) + square(transformed_direction_vector.y));
    return l_projection_2d / l_coord_R_l_angle_bisector_2d;
  }
}

float calculate_l_angle_bisector_2d_irregular_elliptical(float r_gon_sides,
                                                         float r_gon_roundness,
                                                         vector2 coord,
                                                         float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;
  float ref_A_bevel_start = ref_A_angle_bisector -
                            atan((1 - r_gon_roundness) * tan(ref_A_angle_bisector));

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;
  float inner_last_bevel_start_A_x_axis = last_angle_bisector_A_x_axis -
                                          atan((1 - r_gon_roundness) *
                                               tan(last_angle_bisector_A_x_axis));

  if ((x_axis_A_coord >= ref_A_bevel_start) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - ref_A_bevel_start))
  {
    if ((ref_A_coord >= ref_A_bevel_start) && (ref_A_coord < ref_A_next_ref - ref_A_bevel_start)) {
      return l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
    }
    else {
      /* SA == Signed Angle in [-M_PI, M_PI]. Counterclockwise angles are positive, clockwise
       * angles are negative.*/
      float nearest_ref_SA_coord = ref_A_coord -
                                   float(ref_A_coord > ref_A_angle_bisector) * ref_A_next_ref;
      float l_circle_radius = sin(ref_A_bevel_start) / sin(ref_A_angle_bisector);
      float l_circle_center = sin(ref_A_angle_bisector - ref_A_bevel_start) /
                              sin(ref_A_angle_bisector);
      float l_coord_R_l_bevel_start = cos(nearest_ref_SA_coord) * l_circle_center +
                                      sqrt(square(cos(nearest_ref_SA_coord) * l_circle_center) +
                                           square(l_circle_radius) - square(l_circle_center));
      return cos(ref_A_angle_bisector - ref_A_bevel_start) * l_projection_2d /
             l_coord_R_l_bevel_start;
    }
  }
  else {
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis + inner_last_bevel_start_A_x_axis) &&
        (x_axis_A_coord < M_TAU - inner_last_bevel_start_A_x_axis))
    {
      float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                             cos(last_angle_bisector_A_x_axis);
      return l_projection_2d * cos(last_angle_bisector_A_x_axis - ref_A_coord) *
             l_angle_bisector_2d_R_l_last_angle_bisector_2d;
    }
    else {
      /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
       * to avoid a case distinction. */
      float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
      if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_bevel_start) &&
          (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
      {
        nearest_ref_MSA_coord += last_ref_A_x_axis;
        nearest_ref_MSA_coord *= -1;
      }
      float l_basis_vector_1 = r_gon_roundness * tan(ref_A_angle_bisector);
      float l_basis_vector_2 = r_gon_roundness * sin(last_angle_bisector_A_x_axis) *
                               sqrt(square(tan(ref_A_angle_bisector)) + 1.0);
      vector2 ellipse_center =
          vector2(cos(ref_A_bevel_start) / cos(ref_A_angle_bisector - ref_A_bevel_start),
                  sin(ref_A_bevel_start) / cos(ref_A_angle_bisector - ref_A_bevel_start)) -
          l_basis_vector_2 *
              vector2(sin(last_angle_bisector_A_x_axis), cos(last_angle_bisector_A_x_axis));
      vector2 transformed_direction_vector = vector2(
          cos(last_angle_bisector_A_x_axis + nearest_ref_MSA_coord) /
              (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
          cos(ref_A_angle_bisector - nearest_ref_MSA_coord) /
              (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
      vector2 transformed_origin = vector2(
          (ellipse_center.y * sin(last_angle_bisector_A_x_axis) -
           ellipse_center.x * cos(last_angle_bisector_A_x_axis)) /
              (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
          -(ellipse_center.y * sin(ref_A_angle_bisector) +
            ellipse_center.x * cos(ref_A_angle_bisector)) /
              (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
      float l_coord_R_l_angle_bisector_2d =
          (-(transformed_direction_vector.x * transformed_origin.x +
             transformed_direction_vector.y * transformed_origin.y) +
           sqrt(square(transformed_direction_vector.x * transformed_origin.x +
                       transformed_direction_vector.y * transformed_origin.y) -
                (square(transformed_direction_vector.x) + square(transformed_direction_vector.y)) *
                    (square(transformed_origin.x) + square(transformed_origin.y) - 1.0))) /
          (square(transformed_direction_vector.x) + square(transformed_direction_vector.y));
      return l_projection_2d / l_coord_R_l_angle_bisector_2d;
    }
  }
}

float calculate_l_angle_bisector_2d_full_roundness_irregular_circular(float r_gon_sides,
                                                                      vector2 coord,
                                                                      float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;
  float l_last_circle_radius = tan(last_angle_bisector_A_x_axis) /
                               tan(0.5 * (ref_A_angle_bisector + last_angle_bisector_A_x_axis));
  vector2 last_circle_center = vector2(
      cos(last_angle_bisector_A_x_axis) - l_last_circle_radius * cos(last_angle_bisector_A_x_axis),
      l_last_circle_radius * sin(last_angle_bisector_A_x_axis) -
          sin(last_angle_bisector_A_x_axis));
  vector2 outer_last_bevel_start = last_circle_center +
                                   l_last_circle_radius * vector2(cos(ref_A_angle_bisector),
                                                                  sin(ref_A_angle_bisector));
  float x_axis_A_outer_last_bevel_start = atan(outer_last_bevel_start.y /
                                               outer_last_bevel_start.x);

  if ((x_axis_A_coord >= x_axis_A_outer_last_bevel_start) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start))
  {
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_angle_bisector) ||
        (x_axis_A_coord < ref_A_angle_bisector))
    {
      return l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
    }
    else {
      return l_projection_2d;
    }
  }
  else {
    /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
     * to avoid a case distinction. */
    float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start) &&
        (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
    {
      nearest_ref_MSA_coord += last_ref_A_x_axis;
      nearest_ref_MSA_coord *= -1;
    }
    float l_coord_R_l_last_angle_bisector_2d =
        sin(nearest_ref_MSA_coord) * last_circle_center.y +
        cos(nearest_ref_MSA_coord) * last_circle_center.x +
        sqrt(square(sin(nearest_ref_MSA_coord) * last_circle_center.y +
                    cos(nearest_ref_MSA_coord) * last_circle_center.x) +
             square(l_last_circle_radius) - square(last_circle_center.x) -
             square(last_circle_center.y));
    return (cos(ref_A_angle_bisector) * l_projection_2d) /
           (cos(last_angle_bisector_A_x_axis) * l_coord_R_l_last_angle_bisector_2d);
  }
}

float calculate_l_angle_bisector_2d_irregular_circular(float r_gon_sides,
                                                       float r_gon_roundness,
                                                       vector2 coord,
                                                       float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;
  float ref_A_bevel_start = ref_A_angle_bisector -
                            atan((1 - r_gon_roundness) * tan(ref_A_angle_bisector));

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;
  float inner_last_bevel_start_A_x_axis = last_angle_bisector_A_x_axis -
                                          atan((1 - r_gon_roundness) *
                                               tan(last_angle_bisector_A_x_axis));
  float l_last_circle_radius = r_gon_roundness * tan(last_angle_bisector_A_x_axis) /
                               tan(0.5 * (ref_A_angle_bisector + last_angle_bisector_A_x_axis));
  vector2 last_circle_center = vector2(
      (cos(inner_last_bevel_start_A_x_axis) /
       cos(last_angle_bisector_A_x_axis - inner_last_bevel_start_A_x_axis)) -
          l_last_circle_radius * cos(last_angle_bisector_A_x_axis),
      l_last_circle_radius * sin(last_angle_bisector_A_x_axis) -
          (sin(inner_last_bevel_start_A_x_axis) /
           cos(last_angle_bisector_A_x_axis - inner_last_bevel_start_A_x_axis)));
  vector2 outer_last_bevel_start = last_circle_center +
                                   l_last_circle_radius * vector2(cos(ref_A_angle_bisector),
                                                                  sin(ref_A_angle_bisector));
  float x_axis_A_outer_last_bevel_start = atan(outer_last_bevel_start.y /
                                               outer_last_bevel_start.x);

  if ((x_axis_A_coord >= x_axis_A_outer_last_bevel_start) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start))
  {
    if (((ref_A_coord >= ref_A_bevel_start) &&
         (ref_A_coord < ref_A_next_ref - ref_A_bevel_start)) ||
        (x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_bevel_start) ||
        (x_axis_A_coord < ref_A_bevel_start))
    {
      return l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
    }
    else {
      /* SA == Signed Angle in [-M_PI, M_PI]. Counterclockwise angles are positive, clockwise
       * angles are negative.*/
      float nearest_ref_SA_coord = ref_A_coord -
                                   float(ref_A_coord > ref_A_angle_bisector) * ref_A_next_ref;
      float l_circle_radius = sin(ref_A_bevel_start) / sin(ref_A_angle_bisector);
      float l_circle_center = sin(ref_A_angle_bisector - ref_A_bevel_start) /
                              sin(ref_A_angle_bisector);
      float l_coord_R_l_bevel_start = cos(nearest_ref_SA_coord) * l_circle_center +
                                      sqrt(square(cos(nearest_ref_SA_coord) * l_circle_center) +
                                           square(l_circle_radius) - square(l_circle_center));
      return cos(ref_A_angle_bisector - ref_A_bevel_start) * l_projection_2d /
             l_coord_R_l_bevel_start;
    }
  }
  else {
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis + inner_last_bevel_start_A_x_axis) &&
        (x_axis_A_coord < M_TAU - inner_last_bevel_start_A_x_axis))
    {
      float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                             cos(last_angle_bisector_A_x_axis);
      return l_projection_2d * cos(last_angle_bisector_A_x_axis - ref_A_coord) *
             l_angle_bisector_2d_R_l_last_angle_bisector_2d;
    }
    else {
      /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
       * to avoid a case distinction. */
      float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
      if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start) &&
          (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
      {
        nearest_ref_MSA_coord += last_ref_A_x_axis;
        nearest_ref_MSA_coord *= -1;
      }
      float l_coord_R_l_last_angle_bisector_2d =
          sin(nearest_ref_MSA_coord) * last_circle_center.y +
          cos(nearest_ref_MSA_coord) * last_circle_center.x +
          sqrt(square(sin(nearest_ref_MSA_coord) * last_circle_center.y +
                      cos(nearest_ref_MSA_coord) * last_circle_center.x) +
               square(l_last_circle_radius) - square(last_circle_center.x) -
               square(last_circle_center.y));
      return (cos(ref_A_angle_bisector) * l_projection_2d) /
             (cos(last_angle_bisector_A_x_axis) * l_coord_R_l_last_angle_bisector_2d);
    }
  }
}

float calculate_l_angle_bisector_2d(int integer_sides,
                                    int elliptical_corners,
                                    float r_gon_sides,
                                    float r_gon_roundness,
                                    float r_gon_exponent,
                                    vector2 coord)
{
  float l_projection_2d = p_norm(coord, r_gon_exponent);

  if (integer_sides || (fract(r_gon_sides) == 0.0)) {
    if (r_gon_roundness == 0.0) {
      float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
      float ref_A_angle_bisector = M_PI / r_gon_sides;
      float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
      float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
      float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;
      return l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
    }
    if (r_gon_roundness == 1.0) {
      return l_projection_2d;
    }
    else {
      float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
      float ref_A_angle_bisector = M_PI / r_gon_sides;
      float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
      float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
      float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;
      float ref_A_bevel_start = ref_A_angle_bisector -
                                atan((1 - r_gon_roundness) * tan(ref_A_angle_bisector));

      if ((ref_A_coord >= ref_A_next_ref - ref_A_bevel_start) || (ref_A_coord < ref_A_bevel_start))
      {
        /* SA == Signed Angle in [-M_PI, M_PI]. Counterclockwise angles are positive, clockwise
         * angles are negative.*/
        float nearest_ref_SA_coord = ref_A_coord -
                                     float(ref_A_coord > ref_A_angle_bisector) * ref_A_next_ref;
        float l_circle_radius = sin(ref_A_bevel_start) / sin(ref_A_angle_bisector);
        float l_circle_center = sin(ref_A_angle_bisector - ref_A_bevel_start) /
                                sin(ref_A_angle_bisector);
        float l_coord_R_l_bevel_start = cos(nearest_ref_SA_coord) * l_circle_center +
                                        sqrt(square(cos(nearest_ref_SA_coord) * l_circle_center) +
                                             square(l_circle_radius) - square(l_circle_center));
        return cos(ref_A_angle_bisector - ref_A_bevel_start) * l_projection_2d /
               l_coord_R_l_bevel_start;
      }
      else {
        return l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
      }
    }
  }
  else {
    if (r_gon_roundness == 0.0) {
      float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
      float ref_A_angle_bisector = M_PI / r_gon_sides;
      float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
      float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
      float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;

      float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
      float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;

      if (x_axis_A_coord < M_TAU - last_ref_A_x_axis) {
        return l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
      }
      else {
        float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                               cos(last_angle_bisector_A_x_axis);
        return l_projection_2d * cos(last_angle_bisector_A_x_axis - ref_A_coord) *
               l_angle_bisector_2d_R_l_last_angle_bisector_2d;
      }
    }
    if (r_gon_roundness == 1.0) {
      if (elliptical_corners) {
        return calculate_l_angle_bisector_2d_full_roundness_irregular_elliptical(
            r_gon_sides, coord, l_projection_2d);
      }
      else {
        return calculate_l_angle_bisector_2d_full_roundness_irregular_circular(
            r_gon_sides, coord, l_projection_2d);
      }
    }
    else {
      if (elliptical_corners) {
        return calculate_l_angle_bisector_2d_irregular_elliptical(
            r_gon_sides, r_gon_roundness, coord, l_projection_2d);
      }
      else {
        return calculate_l_angle_bisector_2d_irregular_circular(
            r_gon_sides, r_gon_roundness, coord, l_projection_2d);
      }
    }
  }
}

float calculate_l_angle_bisector_4d(int integer_sides,
                                    int elliptical_corners,
                                    float r_gon_sides,
                                    float r_gon_roundness,
                                    float r_gon_exponent,
                                    float sphere_exponent,
                                    vector4 coord)
{
  return p_norm(
      vector3(calculate_l_angle_bisector_2d(integer_sides,
                                            elliptical_corners,
                                            integer_sides ? ceil(r_gon_sides) : r_gon_sides,
                                            r_gon_roundness,
                                            r_gon_exponent,
                                            vector2(coord.x, coord.y)),
              coord.z,
              coord.w),
      sphere_exponent);
}

vector4 calculate_out_fields_2d_full_roundness_irregular_elliptical(
    int calculate_r_sphere_field,
    int calculate_r_gon_parameter_field,
    int normalize_r_gon_parameter,
    float r_gon_sides,
    vector2 coord,
    float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;

  if ((x_axis_A_coord >= ref_A_angle_bisector) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - ref_A_angle_bisector))
  {
    float r_gon_parameter_2d = 0.0;
    if (calculate_r_gon_parameter_field) {
      r_gon_parameter_2d = abs(ref_A_angle_bisector - ref_A_coord);
      if (ref_A_coord < ref_A_angle_bisector) {
        r_gon_parameter_2d *= -1.0;
      }
      if (normalize_r_gon_parameter) {
        r_gon_parameter_2d /= ref_A_angle_bisector;
      }
    }
    return vector4(l_projection_2d, r_gon_parameter_2d, ref_A_angle_bisector, segment_id);
  }
  else {
    /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
     * to avoid a case distinction. */
    float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_angle_bisector) &&
        (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
    {
      nearest_ref_MSA_coord += last_ref_A_x_axis;
      nearest_ref_MSA_coord *= -1;
    }
    float l_angle_bisector_2d = 0.0;
    float r_gon_parameter_2d = 0.0;
    float max_unit_parameter_2d = 0.0;
    if (calculate_r_sphere_field) {
      float l_basis_vector_1 = tan(ref_A_angle_bisector);
      /* When the fractional part of r_gon_sides is very small division by l_basis_vector_2 causes
       * precision issues. Change to double if necessary */
      float l_basis_vector_2 = sin(last_angle_bisector_A_x_axis) *
                               sqrt(square(tan(ref_A_angle_bisector)) + 1.0);
      vector2 ellipse_center =
          vector2(cos(ref_A_angle_bisector) / cos(ref_A_angle_bisector - ref_A_angle_bisector),
                  sin(ref_A_angle_bisector) / cos(ref_A_angle_bisector - ref_A_angle_bisector)) -
          l_basis_vector_2 *
              vector2(sin(last_angle_bisector_A_x_axis), cos(last_angle_bisector_A_x_axis));
      vector2 transformed_direction_vector = vector2(
          cos(last_angle_bisector_A_x_axis + nearest_ref_MSA_coord) /
              (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
          cos(ref_A_angle_bisector - nearest_ref_MSA_coord) /
              (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
      vector2 transformed_origin = vector2(
          (ellipse_center.y * sin(last_angle_bisector_A_x_axis) -
           ellipse_center.x * cos(last_angle_bisector_A_x_axis)) /
              (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
          -(ellipse_center.y * sin(ref_A_angle_bisector) +
            ellipse_center.x * cos(ref_A_angle_bisector)) /
              (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
      float l_coord_R_l_angle_bisector_2d =
          (-(transformed_direction_vector.x * transformed_origin.x +
             transformed_direction_vector.y * transformed_origin.y) +
           sqrt(square(transformed_direction_vector.x * transformed_origin.x +
                       transformed_direction_vector.y * transformed_origin.y) -
                (square(transformed_direction_vector.x) + square(transformed_direction_vector.y)) *
                    (square(transformed_origin.x) + square(transformed_origin.y) - 1.0))) /
          (square(transformed_direction_vector.x) + square(transformed_direction_vector.y));
      l_angle_bisector_2d = l_projection_2d / l_coord_R_l_angle_bisector_2d;
      if (nearest_ref_MSA_coord < 0.0) {
        float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                               cos(last_angle_bisector_A_x_axis);
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = (last_angle_bisector_A_x_axis + nearest_ref_MSA_coord) *
                               l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          if (ref_A_coord < last_angle_bisector_A_x_axis) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= last_angle_bisector_A_x_axis *
                                  l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          }
        }
        max_unit_parameter_2d = last_angle_bisector_A_x_axis *
                                l_angle_bisector_2d_R_l_last_angle_bisector_2d;
      }
      else {
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = abs(ref_A_angle_bisector - ref_A_coord);
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= ref_A_angle_bisector;
          }
        }
        max_unit_parameter_2d = ref_A_angle_bisector;
      }
    }
    return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
  }
}

vector4 calculate_out_fields_2d_irregular_elliptical(int calculate_r_sphere_field,
                                                     int calculate_r_gon_parameter_field,
                                                     int calculate_max_unit_parameter_field,
                                                     int normalize_r_gon_parameter,
                                                     float r_gon_sides,
                                                     float r_gon_roundness,
                                                     vector2 coord,
                                                     float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;
  float ref_A_bevel_start = ref_A_angle_bisector -
                            atan((1 - r_gon_roundness) * tan(ref_A_angle_bisector));

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;
  float inner_last_bevel_start_A_x_axis = last_angle_bisector_A_x_axis -
                                          atan((1 - r_gon_roundness) *
                                               tan(last_angle_bisector_A_x_axis));

  if ((x_axis_A_coord >= ref_A_bevel_start) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - ref_A_bevel_start))
  {
    if ((ref_A_coord >= ref_A_bevel_start) && (ref_A_coord < ref_A_next_ref - ref_A_bevel_start)) {
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(ref_A_angle_bisector - ref_A_coord));
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d *
                                      tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                  ref_A_bevel_start;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                  ref_A_bevel_start;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
    else {
      /* SA == Signed Angle in [-M_PI, M_PI]. Counterclockwise angles are positive, clockwise
       * angles are negative.*/
      float nearest_ref_SA_coord = ref_A_coord -
                                   float(ref_A_coord > ref_A_angle_bisector) * ref_A_next_ref;
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        float l_circle_radius = sin(ref_A_bevel_start) / sin(ref_A_angle_bisector);
        float l_circle_center = sin(ref_A_angle_bisector - ref_A_bevel_start) /
                                sin(ref_A_angle_bisector);
        float l_coord_R_l_bevel_start = cos(nearest_ref_SA_coord) * l_circle_center +
                                        sqrt(square(cos(nearest_ref_SA_coord) * l_circle_center) +
                                             square(l_circle_radius) - square(l_circle_center));
        l_angle_bisector_2d = cos(ref_A_angle_bisector - ref_A_bevel_start) * l_projection_2d /
                              l_coord_R_l_bevel_start;
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d *
                                   tan(ref_A_angle_bisector - ref_A_bevel_start) +
                               ref_A_bevel_start - abs(nearest_ref_SA_coord);
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d *
                                      tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                  ref_A_bevel_start;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                  ref_A_bevel_start;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
  }
  else {
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis + inner_last_bevel_start_A_x_axis) &&
        (x_axis_A_coord < M_TAU - inner_last_bevel_start_A_x_axis))
    {
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                               cos(last_angle_bisector_A_x_axis);
        l_angle_bisector_2d = l_projection_2d * cos(last_angle_bisector_A_x_axis - ref_A_coord) *
                              l_angle_bisector_2d_R_l_last_angle_bisector_2d;
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d *
                               tan(abs(last_angle_bisector_A_x_axis - ref_A_coord));
          if (ref_A_coord < last_angle_bisector_A_x_axis) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d * tan(last_angle_bisector_A_x_axis -
                                                            inner_last_bevel_start_A_x_axis) +
                                  inner_last_bevel_start_A_x_axis *
                                      l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(last_angle_bisector_A_x_axis -
                                      inner_last_bevel_start_A_x_axis) +
                                  inner_last_bevel_start_A_x_axis *
                                      l_angle_bisector_2d_R_l_last_angle_bisector_2d;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
    else {
      /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
       * to avoid a case distinction. */
      float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
      if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_bevel_start) &&
          (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
      {
        nearest_ref_MSA_coord += last_ref_A_x_axis;
        nearest_ref_MSA_coord *= -1;
      }
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        float l_basis_vector_1 = r_gon_roundness * tan(ref_A_angle_bisector);
        float l_basis_vector_2 = r_gon_roundness * sin(last_angle_bisector_A_x_axis) *
                                 sqrt(square(tan(ref_A_angle_bisector)) + 1.0);
        vector2 ellipse_center =
            vector2(cos(ref_A_bevel_start) / cos(ref_A_angle_bisector - ref_A_bevel_start),
                    sin(ref_A_bevel_start) / cos(ref_A_angle_bisector - ref_A_bevel_start)) -
            l_basis_vector_2 *
                vector2(sin(last_angle_bisector_A_x_axis), cos(last_angle_bisector_A_x_axis));
        vector2 transformed_direction_vector = vector2(
            cos(last_angle_bisector_A_x_axis + nearest_ref_MSA_coord) /
                (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
            cos(ref_A_angle_bisector - nearest_ref_MSA_coord) /
                (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
        vector2 transformed_origin = vector2(
            (ellipse_center.y * sin(last_angle_bisector_A_x_axis) -
             ellipse_center.x * cos(last_angle_bisector_A_x_axis)) /
                (l_basis_vector_1 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)),
            -(ellipse_center.y * sin(ref_A_angle_bisector) +
              ellipse_center.x * cos(ref_A_angle_bisector)) /
                (l_basis_vector_2 * sin(ref_A_angle_bisector + last_angle_bisector_A_x_axis)));
        float l_coord_R_l_angle_bisector_2d =
            (-(transformed_direction_vector.x * transformed_origin.x +
               transformed_direction_vector.y * transformed_origin.y) +
             sqrt(square(transformed_direction_vector.x * transformed_origin.x +
                         transformed_direction_vector.y * transformed_origin.y) -
                  (square(transformed_direction_vector.x) +
                   square(transformed_direction_vector.y)) *
                      (square(transformed_origin.x) + square(transformed_origin.y) - 1.0))) /
            (square(transformed_direction_vector.x) + square(transformed_direction_vector.y));
        l_angle_bisector_2d = l_projection_2d / l_coord_R_l_angle_bisector_2d;
        if (nearest_ref_MSA_coord < 0.0) {
          float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                                 cos(last_angle_bisector_A_x_axis);
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(last_angle_bisector_A_x_axis -
                                                               inner_last_bevel_start_A_x_axis)) +
                                 (inner_last_bevel_start_A_x_axis + nearest_ref_MSA_coord) *
                                     l_angle_bisector_2d_R_l_last_angle_bisector_2d;
            if (ref_A_coord < last_angle_bisector_A_x_axis) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d * tan(last_angle_bisector_A_x_axis -
                                                              inner_last_bevel_start_A_x_axis) +
                                    inner_last_bevel_start_A_x_axis *
                                        l_angle_bisector_2d_R_l_last_angle_bisector_2d;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(last_angle_bisector_A_x_axis -
                                        inner_last_bevel_start_A_x_axis) +
                                    inner_last_bevel_start_A_x_axis *
                                        l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          }
        }
        else {
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                     tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                 ref_A_bevel_start - nearest_ref_MSA_coord;
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d *
                                        tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
          }
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
  }
}

vector4 calculate_out_fields_2d_full_roundness_irregular_circular(
    int calculate_r_sphere_field,
    int calculate_r_gon_parameter_field,
    int calculate_max_unit_parameter_field,
    int normalize_r_gon_parameter,
    float r_gon_sides,
    vector2 coord,
    float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;
  float l_last_circle_radius = tan(last_angle_bisector_A_x_axis) /
                               tan(0.5 * (ref_A_angle_bisector + last_angle_bisector_A_x_axis));
  vector2 last_circle_center = vector2(
      cos(last_angle_bisector_A_x_axis) - l_last_circle_radius * cos(last_angle_bisector_A_x_axis),
      l_last_circle_radius * sin(last_angle_bisector_A_x_axis) -
          sin(last_angle_bisector_A_x_axis));
  vector2 outer_last_bevel_start = last_circle_center +
                                   l_last_circle_radius * vector2(cos(ref_A_angle_bisector),
                                                                  sin(ref_A_angle_bisector));
  float x_axis_A_outer_last_bevel_start = atan(outer_last_bevel_start.y /
                                               outer_last_bevel_start.x);

  if ((x_axis_A_coord >= x_axis_A_outer_last_bevel_start) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start))
  {
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_angle_bisector) ||
        (x_axis_A_coord < ref_A_angle_bisector))
    {
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(ref_A_angle_bisector - ref_A_coord));
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d *
                                      tan(ref_A_angle_bisector - x_axis_A_outer_last_bevel_start) +
                                  x_axis_A_outer_last_bevel_start;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(ref_A_angle_bisector - x_axis_A_outer_last_bevel_start) +
                                  x_axis_A_outer_last_bevel_start;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
    else {
      float r_gon_parameter_2d = 0.0;
      if (calculate_r_gon_parameter_field) {
        r_gon_parameter_2d = abs(ref_A_angle_bisector - ref_A_coord);
        if (ref_A_coord < ref_A_angle_bisector) {
          r_gon_parameter_2d *= -1.0;
        }
        if (normalize_r_gon_parameter) {
          r_gon_parameter_2d /= ref_A_angle_bisector;
        }
      }
      return vector4(l_projection_2d, r_gon_parameter_2d, ref_A_angle_bisector, segment_id);
    }
  }
  else {
    /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
     * to avoid a case distinction. */
    float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start) &&
        (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
    {
      nearest_ref_MSA_coord += last_ref_A_x_axis;
      nearest_ref_MSA_coord *= -1;
    }
    float l_angle_bisector_2d = 0.0;
    float r_gon_parameter_2d = 0.0;
    float max_unit_parameter_2d = 0.0;
    if (calculate_r_sphere_field) {
      float l_coord_R_l_last_angle_bisector_2d =
          sin(nearest_ref_MSA_coord) * last_circle_center.y +
          cos(nearest_ref_MSA_coord) * last_circle_center.x +
          sqrt(square(sin(nearest_ref_MSA_coord) * last_circle_center.y +
                      cos(nearest_ref_MSA_coord) * last_circle_center.x) +
               square(l_last_circle_radius) - square(last_circle_center.x) -
               square(last_circle_center.y));
      l_angle_bisector_2d = (cos(ref_A_angle_bisector) * l_projection_2d) /
                            (cos(last_angle_bisector_A_x_axis) *
                             l_coord_R_l_last_angle_bisector_2d);
      if (nearest_ref_MSA_coord < 0.0) {
        float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                               cos(last_angle_bisector_A_x_axis);
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = (last_angle_bisector_A_x_axis + nearest_ref_MSA_coord) *
                               l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          if (ref_A_coord < last_angle_bisector_A_x_axis) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= last_angle_bisector_A_x_axis *
                                  l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          }
        }
        max_unit_parameter_2d = last_angle_bisector_A_x_axis *
                                l_angle_bisector_2d_R_l_last_angle_bisector_2d;
      }
      else {
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(ref_A_angle_bisector -
                                                             x_axis_A_outer_last_bevel_start)) +
                               x_axis_A_outer_last_bevel_start - nearest_ref_MSA_coord;
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d *
                                      tan(ref_A_angle_bisector - x_axis_A_outer_last_bevel_start) +
                                  x_axis_A_outer_last_bevel_start;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(ref_A_angle_bisector - x_axis_A_outer_last_bevel_start) +
                                  x_axis_A_outer_last_bevel_start;
        }
      }
    }
    return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
  }
}

vector4 calculate_out_fields_2d_irregular_circular(int calculate_r_sphere_field,
                                                   int calculate_r_gon_parameter_field,
                                                   int calculate_max_unit_parameter_field,
                                                   int normalize_r_gon_parameter,
                                                   float r_gon_sides,
                                                   float r_gon_roundness,
                                                   vector2 coord,
                                                   float l_projection_2d)
{
  float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
  float ref_A_angle_bisector = M_PI / r_gon_sides;
  float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
  float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
  float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;
  float ref_A_bevel_start = ref_A_angle_bisector -
                            atan((1 - r_gon_roundness) * tan(ref_A_angle_bisector));

  float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
  float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;
  float inner_last_bevel_start_A_x_axis = last_angle_bisector_A_x_axis -
                                          atan((1 - r_gon_roundness) *
                                               tan(last_angle_bisector_A_x_axis));
  float l_last_circle_radius = r_gon_roundness * tan(last_angle_bisector_A_x_axis) /
                               tan(0.5 * (ref_A_angle_bisector + last_angle_bisector_A_x_axis));
  vector2 last_circle_center = vector2(
      (cos(inner_last_bevel_start_A_x_axis) /
       cos(last_angle_bisector_A_x_axis - inner_last_bevel_start_A_x_axis)) -
          l_last_circle_radius * cos(last_angle_bisector_A_x_axis),
      l_last_circle_radius * sin(last_angle_bisector_A_x_axis) -
          (sin(inner_last_bevel_start_A_x_axis) /
           cos(last_angle_bisector_A_x_axis - inner_last_bevel_start_A_x_axis)));
  vector2 outer_last_bevel_start = last_circle_center +
                                   l_last_circle_radius * vector2(cos(ref_A_angle_bisector),
                                                                  sin(ref_A_angle_bisector));
  float x_axis_A_outer_last_bevel_start = atan(outer_last_bevel_start.y /
                                               outer_last_bevel_start.x);

  if ((x_axis_A_coord >= x_axis_A_outer_last_bevel_start) &&
      (x_axis_A_coord < M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start))
  {
    if (((ref_A_coord >= ref_A_bevel_start) &&
         (ref_A_coord < ref_A_next_ref - ref_A_bevel_start)) ||
        (x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_bevel_start) ||
        (x_axis_A_coord < ref_A_bevel_start))
    {
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
        if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - ref_A_angle_bisector) ||
            (x_axis_A_coord < ref_A_angle_bisector))
        {
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                 tan(abs(ref_A_angle_bisector - ref_A_coord));
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d * tan(ref_A_angle_bisector -
                                                              x_axis_A_outer_last_bevel_start) +
                                    x_axis_A_outer_last_bevel_start;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector - x_axis_A_outer_last_bevel_start) +
                                    x_axis_A_outer_last_bevel_start;
          }
        }
        else {
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                 tan(abs(ref_A_angle_bisector - ref_A_coord));
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d *
                                        tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
          }
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
    else {
      /* SA == Signed Angle in [-M_PI, M_PI]. Counterclockwise angles are positive, clockwise
       * angles are negative.*/
      float nearest_ref_SA_coord = ref_A_coord -
                                   float(ref_A_coord > ref_A_angle_bisector) * ref_A_next_ref;
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        float l_circle_radius = sin(ref_A_bevel_start) / sin(ref_A_angle_bisector);
        float l_circle_center = sin(ref_A_angle_bisector - ref_A_bevel_start) /
                                sin(ref_A_angle_bisector);
        float l_coord_R_l_bevel_start = cos(nearest_ref_SA_coord) * l_circle_center +
                                        sqrt(square(cos(nearest_ref_SA_coord) * l_circle_center) +
                                             square(l_circle_radius) - square(l_circle_center));
        l_angle_bisector_2d = cos(ref_A_angle_bisector - ref_A_bevel_start) * l_projection_2d /
                              l_coord_R_l_bevel_start;
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d *
                                   tan(ref_A_angle_bisector - ref_A_bevel_start) +
                               ref_A_bevel_start - abs(nearest_ref_SA_coord);
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d *
                                      tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                  ref_A_bevel_start;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                  ref_A_bevel_start;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
  }
  else {
    if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis + inner_last_bevel_start_A_x_axis) &&
        (x_axis_A_coord < M_TAU - inner_last_bevel_start_A_x_axis))
    {
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                               cos(last_angle_bisector_A_x_axis);
        l_angle_bisector_2d = l_projection_2d * cos(last_angle_bisector_A_x_axis - ref_A_coord) *
                              l_angle_bisector_2d_R_l_last_angle_bisector_2d;
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d *
                               tan(abs(last_angle_bisector_A_x_axis - ref_A_coord));
          if (ref_A_coord < last_angle_bisector_A_x_axis) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter) {
            r_gon_parameter_2d /= l_angle_bisector_2d * tan(last_angle_bisector_A_x_axis -
                                                            inner_last_bevel_start_A_x_axis) +
                                  inner_last_bevel_start_A_x_axis *
                                      l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = tan(last_angle_bisector_A_x_axis -
                                      inner_last_bevel_start_A_x_axis) +
                                  inner_last_bevel_start_A_x_axis *
                                      l_angle_bisector_2d_R_l_last_angle_bisector_2d;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
    else {
      /* MSA == Mirrored Signed Angle. The values are mirrored around the last angle bisector
       * to avoid a case distinction. */
      float nearest_ref_MSA_coord = atan2(coord.y, coord.x);
      if ((x_axis_A_coord >= M_TAU - last_ref_A_x_axis - x_axis_A_outer_last_bevel_start) &&
          (x_axis_A_coord < M_TAU - last_angle_bisector_A_x_axis))
      {
        nearest_ref_MSA_coord += last_ref_A_x_axis;
        nearest_ref_MSA_coord *= -1;
      }
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        float l_coord_R_l_last_angle_bisector_2d =
            sin(nearest_ref_MSA_coord) * last_circle_center.y +
            cos(nearest_ref_MSA_coord) * last_circle_center.x +
            sqrt(square(sin(nearest_ref_MSA_coord) * last_circle_center.y +
                        cos(nearest_ref_MSA_coord) * last_circle_center.x) +
                 square(l_last_circle_radius) - square(last_circle_center.x) -
                 square(last_circle_center.y));
        l_angle_bisector_2d = (cos(ref_A_angle_bisector) * l_projection_2d) /
                              (cos(last_angle_bisector_A_x_axis) *
                               l_coord_R_l_last_angle_bisector_2d);
        if (nearest_ref_MSA_coord < 0.0) {
          float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                                 cos(last_angle_bisector_A_x_axis);
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(last_angle_bisector_A_x_axis -
                                                               inner_last_bevel_start_A_x_axis)) +
                                 (inner_last_bevel_start_A_x_axis + nearest_ref_MSA_coord) *
                                     l_angle_bisector_2d_R_l_last_angle_bisector_2d;
            if (ref_A_coord < last_angle_bisector_A_x_axis) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d * tan(last_angle_bisector_A_x_axis -
                                                              inner_last_bevel_start_A_x_axis) +
                                    inner_last_bevel_start_A_x_axis *
                                        l_angle_bisector_2d_R_l_last_angle_bisector_2d;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(last_angle_bisector_A_x_axis -
                                        inner_last_bevel_start_A_x_axis) +
                                    inner_last_bevel_start_A_x_axis *
                                        l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          }
        }
        else {
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(ref_A_angle_bisector -
                                                               x_axis_A_outer_last_bevel_start)) +
                                 x_axis_A_outer_last_bevel_start - nearest_ref_MSA_coord;
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d * tan(ref_A_angle_bisector -
                                                              x_axis_A_outer_last_bevel_start) +
                                    x_axis_A_outer_last_bevel_start;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector - x_axis_A_outer_last_bevel_start) +
                                    x_axis_A_outer_last_bevel_start;
          }
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
  }
}

vector4 calculate_out_fields_2d(int calculate_r_sphere_field,
                                int calculate_r_gon_parameter_field,
                                int calculate_max_unit_parameter_field,
                                int normalize_r_gon_parameter,
                                int integer_sides,
                                int elliptical_corners,
                                float r_gon_sides,
                                float r_gon_roundness,
                                float r_gon_exponent,
                                vector2 coord)
{
  float l_projection_2d = p_norm(coord, r_gon_exponent);

  if (integer_sides || (fract(r_gon_sides) == 0.0)) {
    float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
    float ref_A_angle_bisector = M_PI / r_gon_sides;
    float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
    float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
    float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;

    if (r_gon_roundness == 0.0) {
      float l_angle_bisector_2d = 0.0;
      float r_gon_parameter_2d = 0.0;
      float max_unit_parameter_2d = 0.0;
      if (calculate_r_sphere_field) {
        l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
        if (calculate_r_gon_parameter_field) {
          r_gon_parameter_2d = l_angle_bisector_2d * tan(abs(ref_A_angle_bisector - ref_A_coord));
          if (ref_A_coord < ref_A_angle_bisector) {
            r_gon_parameter_2d *= -1.0;
          }
          if (normalize_r_gon_parameter && (r_gon_sides != 2.0)) {
            r_gon_parameter_2d /= l_angle_bisector_2d * tan(ref_A_angle_bisector);
          }
        }
        if (calculate_max_unit_parameter_field) {
          max_unit_parameter_2d = (r_gon_sides != 2.0) ? tan(ref_A_angle_bisector) : 0.0;
        }
      }
      return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
    }
    if (r_gon_roundness == 1.0) {
      float r_gon_parameter_2d = 0.0;
      if (calculate_r_gon_parameter_field) {
        r_gon_parameter_2d = abs(ref_A_angle_bisector - ref_A_coord);
        if (ref_A_coord < ref_A_angle_bisector) {
          r_gon_parameter_2d *= -1.0;
        }
        if (normalize_r_gon_parameter) {
          r_gon_parameter_2d /= ref_A_angle_bisector;
        }
      }
      return vector4(l_projection_2d, r_gon_parameter_2d, ref_A_angle_bisector, segment_id);
    }
    else {
      float ref_A_bevel_start = ref_A_angle_bisector -
                                atan((1 - r_gon_roundness) * tan(ref_A_angle_bisector));

      if ((ref_A_coord >= ref_A_next_ref - ref_A_bevel_start) || (ref_A_coord < ref_A_bevel_start))
      {
        /* SA == Signed Angle in [-M_PI, M_PI]. Counterclockwise angles are positive, clockwise
         * angles are negative.*/
        float nearest_ref_SA_coord = ref_A_coord -
                                     float(ref_A_coord > ref_A_angle_bisector) * ref_A_next_ref;
        float l_angle_bisector_2d = 0.0;
        float r_gon_parameter_2d = 0.0;
        float max_unit_parameter_2d = 0.0;
        if (calculate_r_sphere_field) {
          float l_circle_radius = sin(ref_A_bevel_start) / sin(ref_A_angle_bisector);
          float l_circle_center = sin(ref_A_angle_bisector - ref_A_bevel_start) /
                                  sin(ref_A_angle_bisector);
          float l_coord_R_l_bevel_start = cos(nearest_ref_SA_coord) * l_circle_center +
                                          sqrt(
                                              square(cos(nearest_ref_SA_coord) * l_circle_center) +
                                              square(l_circle_radius) - square(l_circle_center));
          l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_bevel_start) /
                                l_coord_R_l_bevel_start;
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                     tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                 ref_A_bevel_start - abs(nearest_ref_SA_coord);
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d *
                                        tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
          }
        }
        return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
      }
      else {
        float l_angle_bisector_2d = 0.0;
        float r_gon_parameter_2d = 0.0;
        float max_unit_parameter_2d = 0.0;
        if (calculate_r_sphere_field) {
          l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                 tan(abs(ref_A_angle_bisector - ref_A_coord));
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d *
                                        tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector - ref_A_bevel_start) +
                                    ref_A_bevel_start;
          }
        }
        return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
      }
    }
  }
  else {
    if (r_gon_roundness == 0.0) {
      float x_axis_A_coord = atan2(coord.y, coord.x) + float(coord.y < 0.0) * M_TAU;
      float ref_A_angle_bisector = M_PI / r_gon_sides;
      float ref_A_next_ref = 2.0 * ref_A_angle_bisector;
      float segment_id = floor(x_axis_A_coord / ref_A_next_ref);
      float ref_A_coord = x_axis_A_coord - segment_id * ref_A_next_ref;

      float last_angle_bisector_A_x_axis = M_PI - floor(r_gon_sides) * ref_A_angle_bisector;
      float last_ref_A_x_axis = 2.0 * last_angle_bisector_A_x_axis;

      if (x_axis_A_coord < M_TAU - last_ref_A_x_axis) {
        float l_angle_bisector_2d = 0.0;
        float r_gon_parameter_2d = 0.0;
        float max_unit_parameter_2d = 0.0;
        if (calculate_r_sphere_field) {
          l_angle_bisector_2d = l_projection_2d * cos(ref_A_angle_bisector - ref_A_coord);
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                 tan(abs(ref_A_angle_bisector - ref_A_coord));
            if (ref_A_coord < ref_A_angle_bisector) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d * tan(ref_A_angle_bisector);
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(ref_A_angle_bisector);
          }
        }
        return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
      }
      else {
        float l_angle_bisector_2d = 0.0;
        float r_gon_parameter_2d = 0.0;
        float max_unit_parameter_2d = 0.0;
        if (calculate_r_sphere_field) {
          float l_angle_bisector_2d_R_l_last_angle_bisector_2d = cos(ref_A_angle_bisector) /
                                                                 cos(last_angle_bisector_A_x_axis);
          l_angle_bisector_2d = l_projection_2d * cos(last_angle_bisector_A_x_axis - ref_A_coord) *
                                l_angle_bisector_2d_R_l_last_angle_bisector_2d;
          if (calculate_r_gon_parameter_field) {
            r_gon_parameter_2d = l_angle_bisector_2d *
                                 tan(abs(last_angle_bisector_A_x_axis - ref_A_coord));
            if (ref_A_coord < last_angle_bisector_A_x_axis) {
              r_gon_parameter_2d *= -1.0;
            }
            if (normalize_r_gon_parameter) {
              r_gon_parameter_2d /= l_angle_bisector_2d * tan(last_angle_bisector_A_x_axis);
            }
          }
          if (calculate_max_unit_parameter_field) {
            max_unit_parameter_2d = tan(last_angle_bisector_A_x_axis);
          }
        }
        return vector4(l_angle_bisector_2d, r_gon_parameter_2d, max_unit_parameter_2d, segment_id);
      }
    }
    if (r_gon_roundness == 1.0) {
      if (elliptical_corners) {
        return calculate_out_fields_2d_full_roundness_irregular_elliptical(
            calculate_r_sphere_field,
            calculate_r_gon_parameter_field,
            normalize_r_gon_parameter,
            r_gon_sides,
            coord,
            l_projection_2d);
      }
      else {
        return calculate_out_fields_2d_full_roundness_irregular_circular(
            calculate_r_sphere_field,
            calculate_r_gon_parameter_field,
            calculate_max_unit_parameter_field,
            normalize_r_gon_parameter,
            r_gon_sides,
            coord,
            l_projection_2d);
      }
    }
    else {
      if (elliptical_corners) {
        return calculate_out_fields_2d_irregular_elliptical(calculate_r_sphere_field,
                                                            calculate_r_gon_parameter_field,
                                                            calculate_max_unit_parameter_field,
                                                            normalize_r_gon_parameter,
                                                            r_gon_sides,
                                                            r_gon_roundness,
                                                            coord,
                                                            l_projection_2d);
      }
      else {
        return calculate_out_fields_2d_irregular_circular(calculate_r_sphere_field,
                                                          calculate_r_gon_parameter_field,
                                                          calculate_max_unit_parameter_field,
                                                          normalize_r_gon_parameter,
                                                          r_gon_sides,
                                                          r_gon_roundness,
                                                          coord,
                                                          l_projection_2d);
      }
    }
  }
}

vector4 calculate_out_fields_4d(int calculate_r_sphere_field,
                                int calculate_r_gon_parameter_field,
                                int calculate_max_unit_parameter_field,
                                int normalize_r_gon_parameter,
                                int integer_sides,
                                int elliptical_corners,
                                float r_gon_sides,
                                float r_gon_roundness,
                                float r_gon_exponent,
                                float sphere_exponent,
                                vector4 coord)
{
  vector4 out_fields = calculate_out_fields_2d(calculate_r_sphere_field,
                                               calculate_r_gon_parameter_field,
                                               calculate_max_unit_parameter_field,
                                               normalize_r_gon_parameter,
                                               integer_sides,
                                               elliptical_corners,
                                               integer_sides ? ceil(r_gon_sides) : r_gon_sides,
                                               r_gon_roundness,
                                               r_gon_exponent,
                                               vector2(coord.x, coord.y));
  out_fields.x = p_norm(vector3(out_fields.x, coord.z, coord.w), sphere_exponent);
  return out_fields;
}

void randomize_scale(float scale_randomized[],
                     float scale_randomness[],
                     int scale_index_list[],
                     int scale_index_count,
                     int uniform_scale_randomness,
                     float seed_offset)
{
  if (!uniform_scale_randomness) {
    for (int i = 0; i < scale_index_count; ++i) {
      scale_randomized[scale_index_list[i]] *= pow(
          2.0,
          mix(-scale_randomness[i],
              scale_randomness[i],
              hash_float_to_float(float(scale_index_list[i]) + seed_offset)));
    }
  }
  else if (scale_index_count != 0) {
    float random_scale_factor = pow(
        2.0, mix(-scale_randomness[0], scale_randomness[0], hash_float_to_float(seed_offset)));
    for (int i = 0; i < 4; i++) {
      scale_randomized[i] *= random_scale_factor;
    }
  }
}

void randomize_scale(float scale_randomized[],
                     float scale_randomness[],
                     int scale_index_list[],
                     int scale_index_count,
                     int uniform_scale_randomness,
                     vector2 seed_offset)
{
  if (!uniform_scale_randomness) {
    for (int i = 0; i < scale_index_count; ++i) {
      scale_randomized[scale_index_list[i]] *= pow(
          2.0,
          mix(-scale_randomness[i],
              scale_randomness[i],
              hash_vector2_to_float(vector2(scale_index_list[i], scale_index_list[i]) +
                                    seed_offset)));
    }
  }
  else if (scale_index_count != 0) {
    float random_scale_factor = pow(
        2.0, mix(-scale_randomness[0], scale_randomness[0], hash_vector2_to_float(seed_offset)));
    for (int i = 0; i < 4; i++) {
      scale_randomized[i] *= random_scale_factor;
    }
  }
}

void randomize_scale(float scale_randomized[],
                     float scale_randomness[],
                     int scale_index_list[],
                     int scale_index_count,
                     int uniform_scale_randomness,
                     vector3 seed_offset)
{
  if (!uniform_scale_randomness) {
    for (int i = 0; i < scale_index_count; ++i) {
      scale_randomized[scale_index_list[i]] *= pow(
          2.0,
          mix(-scale_randomness[i],
              scale_randomness[i],
              hash_vector3_to_float(
                  vector3(scale_index_list[i], scale_index_list[i], scale_index_list[i]) +
                  seed_offset)));
    }
  }
  else if (scale_index_count != 0) {
    float random_scale_factor = pow(
        2.0, mix(-scale_randomness[0], scale_randomness[0], hash_vector3_to_float(seed_offset)));
    for (int i = 0; i < 4; i++) {
      scale_randomized[i] *= random_scale_factor;
    }
  }
}

void randomize_scale(float scale_randomized[],
                     float scale_randomness[],
                     int scale_index_list[],
                     int scale_index_count,
                     int uniform_scale_randomness,
                     vector4 seed_offset)
{
  if (!uniform_scale_randomness) {
    for (int i = 0; i < scale_index_count; ++i) {
      scale_randomized[scale_index_list[i]] *= pow(
          2.0,
          mix(-scale_randomness[i],
              scale_randomness[i],
              hash_vector4_to_float(vector4(scale_index_list[i],
                                            scale_index_list[i],
                                            scale_index_list[i],
                                            scale_index_list[i]) +
                                    seed_offset)));
    }
  }
  else if (scale_index_count != 0) {
    float random_scale_factor = pow(
        2.0, mix(-scale_randomness[0], scale_randomness[0], hash_vector4_to_float(seed_offset)));
    for (int i = 0; i < 4; i++) {
      scale_randomized[i] *= random_scale_factor;
    }
  }
}

void randomize_float_array(
    float array[], float min[], float max[], int index_list[], int index_count, float seed_offset)
{
  for (int i = 0; i < index_count; ++i) {
    array[index_list[i]] = mix(
        min[i], max[i], hash_float_to_float(float(index_list[i]) + seed_offset));
  }
}

void randomize_float_array(float array[],
                           float min[],
                           float max[],
                           int index_list[],
                           int index_count,
                           vector2 seed_offset)
{
  for (int i = 0; i < index_count; ++i) {
    array[index_list[i]] = mix(
        min[i],
        max[i],
        hash_vector2_to_float(vector2(index_list[i], index_list[i]) + seed_offset));
  }
}

void randomize_float_array(float array[],
                           float min[],
                           float max[],
                           int index_list[],
                           int index_count,
                           vector3 seed_offset)
{
  for (int i = 0; i < index_count; ++i) {
    array[index_list[i]] = mix(
        min[i],
        max[i],
        hash_vector3_to_float(vector3(index_list[i], index_list[i], index_list[i]) + seed_offset));
  }
}

void randomize_float_array(float array[],
                           float min[],
                           float max[],
                           int index_list[],
                           int index_count,
                           vector4 seed_offset)
{
  for (int i = 0; i < index_count; ++i) {
    array[index_list[i]] = mix(
        min[i],
        max[i],
        hash_vector4_to_float(vector4(index_list[i], index_list[i], index_list[i], index_list[i]) +
                              seed_offset));
  }
}

float elliptical_ramp(float value, float ellipse_height, float ellipse_width)
{
  if (value < 0.0) {
    return 0.0;
  }
  else if (value < ellipse_width + ellipse_height * (1.0 - ellipse_width)) {
    return (ellipse_height *
            (value * ellipse_height * (1.0 - ellipse_width) + square(ellipse_width) -
             ellipse_width * sqrt(square(ellipse_width) - square(value) +
                                  2.0 * value * ellipse_height * (1.0 - ellipse_width)))) /
           (square(ellipse_height * (1.0 - ellipse_width)) + square(ellipse_width));
  }
  else {
    return (ellipse_width == 1.0) ? ellipse_height :
                                    (value - ellipse_width) / (1.0 - ellipse_width);
  }
}

float elliptical_unit_step(float value,
                           float ellipse_height,
                           float ellipse_width,
                           float inflection_point)
{
  if (inflection_point == 0.0) {
    return (value < 0.0) ? 0.0 : 1.0 - elliptical_ramp(1.0 - value, ellipse_height, ellipse_width);
  }
  else if (inflection_point == 1.0) {
    return (value < 1.0) ? elliptical_ramp(value, ellipse_height, ellipse_width) : 1.0;
  }
  else {
    return (value < inflection_point) ?
               inflection_point *
                   elliptical_ramp(value / inflection_point, ellipse_height, ellipse_width) :
               1.0 - (1.0 - inflection_point) *
                         elliptical_ramp((1.0 - value) / (1.0 - inflection_point),
                                         ellipse_height,
                                         ellipse_width);
  }
}

float inverse_mix(float value, float from_min, float from_max)
{
  return (value - from_min) / (from_max - from_min);
}

float elliptical_remap(float value,
                       float from_min,
                       float from_max,
                       float to_min,
                       float to_max,
                       float ellipse_height,
                       float ellipse_width,
                       float inflection_point)
{
  if (from_min == from_max) {
    return (value >= from_min) ? to_max : to_min;
  }
  else {
    return mix(to_min,
               to_max,
               elliptical_unit_step(inverse_mix(value, from_min, from_max),
                                    ellipse_height,
                                    ellipse_width,
                                    inflection_point));
  }
}

float chained_elliptical_remap_1_step(float remap[], float value)
{
  return elliptical_remap(value,
                          /* Step Center 1 - 0.5 * Step Width 1 */
                          remap[0] - 0.5 * remap[1],
                          /* Step Center 1 + 0.5 * Step Width 1 */
                          remap[0] + 0.5 * remap[1],
                          /* Step Value 1 */
                          remap[2],
                          0.0,
                          /* Ellipse Height 1 */
                          remap[3],
                          /* Ellipse Width 1 */
                          remap[4],
                          /* Inflection Point 1 */
                          remap[5]);
}

float chained_elliptical_remap_2_steps(float remap[], float value)
{
  float result = elliptical_remap(value,
                                  /* Step Center 1 - 0.5 * Step Width 1 */
                                  remap[0] - 0.5 * remap[1],
                                  /* Step Center 1 + 0.5 * Step Width 1 */
                                  remap[0] + 0.5 * remap[1],
                                  /* Step Value 1 */
                                  remap[2],
                                  /* Step Value 2 */
                                  remap[8],
                                  /* Ellipse Height 1 */
                                  remap[3],
                                  /* Ellipse Width 1 */
                                  remap[4],
                                  /* Inflection Point 1 */
                                  remap[5]);
  return elliptical_remap(value,
                          /* Step Center 2 - 0.5 * Step Width 2 */
                          remap[6] - 0.5 * remap[7],
                          /* Step Center 2 + 0.5 * Step Width 2 */
                          remap[6] + 0.5 * remap[7],
                          result,
                          0.0,
                          /* Ellipse Height 2 */
                          remap[9],
                          /* Ellipse Width 2 */
                          remap[10],
                          /* Inflection Point 2 */
                          remap[11]);
}

float chained_elliptical_remap_3_steps(float remap[], float value)
{
  float result = elliptical_remap(value,
                                  /* Step Center 1 - 0.5 * Step Width 1 */
                                  remap[0] - 0.5 * remap[1],
                                  /* Step Center 1 + 0.5 * Step Width 1 */
                                  remap[0] + 0.5 * remap[1],
                                  /* Step Value 1 */
                                  remap[2],
                                  /* Step Value 2 */
                                  remap[8],
                                  /* Ellipse Height 1 */
                                  remap[3],
                                  /* Ellipse Width 1 */
                                  remap[4],
                                  /* Inflection Point 1 */
                                  remap[5]);
  result = elliptical_remap(value,
                            /* Step Center 2 - 0.5 * Step Width 2 */
                            remap[6] - 0.5 * remap[7],
                            /* Step Center 2 + 0.5 * Step Width 2 */
                            remap[6] + 0.5 * remap[7],
                            result,
                            /* Step Value 3 */
                            remap[14],
                            /* Ellipse Height 2 */
                            remap[9],
                            /* Ellipse Width 2 */
                            remap[10],
                            /* Inflection Point 2 */
                            remap[11]);
  return elliptical_remap(value,
                          /* Step Center 3 - 0.5 * Step Width 3 */
                          remap[12] - 0.5 * remap[13],
                          /* Step Center 3 + 0.5 * Step Width 3 */
                          remap[12] + 0.5 * remap[13],
                          result,
                          0.0,
                          /* Ellipse Height 3 */
                          remap[15],
                          /* Ellipse Width 3 */
                          remap[16],
                          /* Inflection Point 3 */
                          remap[17]);
}

float chained_elliptical_remap_4_steps(float remap[], float value)
{
  float result = elliptical_remap(value,
                                  /* Step Center 1 - 0.5 * Step Width 1 */
                                  remap[0] - 0.5 * remap[1],
                                  /* Step Center 1 + 0.5 * Step Width 1 */
                                  remap[0] + 0.5 * remap[1],
                                  /* Step Value 1 */
                                  remap[2],
                                  /* Step Value 2 */
                                  remap[8],
                                  /* Ellipse Height 1 */
                                  remap[3],
                                  /* Ellipse Width 1 */
                                  remap[4],
                                  /* Inflection Point 1 */
                                  remap[5]);
  result = elliptical_remap(value,
                            /* Step Center 2 - 0.5 * Step Width 2 */
                            remap[6] - 0.5 * remap[7],
                            /* Step Center 2 + 0.5 * Step Width 2 */
                            remap[6] + 0.5 * remap[7],
                            result,
                            /* Step Value 3 */
                            remap[14],
                            /* Ellipse Height 2 */
                            remap[9],
                            /* Ellipse Width 2 */
                            remap[10],
                            /* Inflection Point 2 */
                            remap[11]);
  result = elliptical_remap(value,
                            /* Step Center 3 - 0.5 * Step Width 3 */
                            remap[12] - 0.5 * remap[13],
                            /* Step Center 3 + 0.5 * Step Width 3 */
                            remap[12] + 0.5 * remap[13],
                            result,
                            /* Step Value 4 */
                            remap[20],
                            /* Ellipse Height 3 */
                            remap[15],
                            /* Ellipse Width 3 */
                            remap[16],
                            /* Inflection Point 3 */
                            remap[17]);
  return elliptical_remap(value,
                          /* Step Center 4 - 0.5 * Step Width 4 */
                          remap[18] - 0.5 * remap[19],
                          /* Step Center 4 + 0.5 * Step Width 4 */
                          remap[18] + 0.5 * remap[19],
                          result,
                          0.0,
                          /* Ellipse Height 4 */
                          remap[21],
                          /* Ellipse Width 4 */
                          remap[22],
                          /* Inflection Point 4 */
                          remap[23]);
}

#define CHAINED_ELLIPTICAL_REMAP_SELECT_STEPS(T) \
  float chained_elliptical_remap_select_steps(string step_count, \
                                              float remap[], \
                                              float remap_min[], \
                                              float remap_max[], \
                                              int remap_index_list[], \
                                              int remap_index_count, \
                                              T seed_offset, \
                                              float value) \
  { \
    float remap_randomized[24]; \
    float result; \
    if (step_count == "1_step") { \
      for (int i = 0; i < 6; ++i) { \
        remap_randomized[i] = remap[i]; \
      } \
      randomize_float_array(remap_randomized, \
                            remap_min, \
                            remap_max, \
                            remap_index_list, \
                            remap_index_count, \
                            seed_offset); \
      result = chained_elliptical_remap_1_step(remap_randomized, value); \
    } \
    else if (step_count == "2_steps") { \
      for (int i = 0; i < 12; ++i) { \
        remap_randomized[i] = remap[i]; \
      } \
      randomize_float_array(remap_randomized, \
                            remap_min, \
                            remap_max, \
                            remap_index_list, \
                            remap_index_count, \
                            seed_offset); \
      result = chained_elliptical_remap_2_steps(remap_randomized, value); \
    } \
    else if (step_count == "3_steps") { \
      for (int i = 0; i < 18; ++i) { \
        remap_randomized[i] = remap[i]; \
      } \
      randomize_float_array(remap_randomized, \
                            remap_min, \
                            remap_max, \
                            remap_index_list, \
                            remap_index_count, \
                            seed_offset); \
      result = chained_elliptical_remap_3_steps(remap_randomized, value); \
    } \
    else { \
      for (int i = 0; i < 24; ++i) { \
        remap_randomized[i] = remap[i]; \
      } \
      randomize_float_array(remap_randomized, \
                            remap_min, \
                            remap_max, \
                            remap_index_list, \
                            remap_index_count, \
                            seed_offset); \
      result = chained_elliptical_remap_4_steps(remap_randomized, value); \
    } \
    return result; \
  }

CHAINED_ELLIPTICAL_REMAP_SELECT_STEPS(float)
CHAINED_ELLIPTICAL_REMAP_SELECT_STEPS(vector2)
CHAINED_ELLIPTICAL_REMAP_SELECT_STEPS(vector3)
CHAINED_ELLIPTICAL_REMAP_SELECT_STEPS(vector4)

vector4 rotate_scale(vector4 Coord,
                     float translation_rotation_randomized[],
                     float scale_randomized[],
                     int invert_order_of_transformation)
{
  /* Alternation between coord1 and coord2 is necessary because of OSL sequencing. */
  vector4 coord1;
  vector4 coord2 = Coord;

  if (invert_order_of_transformation) {
    coord1 = vector4(scale_randomized[0],
                     scale_randomized[1],
                     scale_randomized[2],
                     scale_randomized[3]) *
             coord2;

    if (translation_rotation_randomized[4] != 0.0) {
      coord2 = vector4(coord1.x,
                       cos(translation_rotation_randomized[4]) * coord1.y -
                           sin(translation_rotation_randomized[4]) * coord1.z,
                       sin(translation_rotation_randomized[4]) * coord1.y +
                           cos(translation_rotation_randomized[4]) * coord1.z,
                       coord1.w);
    }
    else {
      coord2 = coord1;
    }
    if (translation_rotation_randomized[5] != 0.0) {
      coord1 = vector4(cos(translation_rotation_randomized[5]) * coord2.x +
                           sin(translation_rotation_randomized[5]) * coord2.z,
                       coord2.y,
                       cos(translation_rotation_randomized[5]) * coord2.z -
                           sin(translation_rotation_randomized[5]) * coord2.x,
                       coord2.w);
    }
    else {
      coord1 = coord2;
    }
    if (translation_rotation_randomized[6] != 0.0) {
      coord2 = vector4(cos(translation_rotation_randomized[6]) * coord1.x -
                           sin(translation_rotation_randomized[6]) * coord1.y,
                       sin(translation_rotation_randomized[6]) * coord1.x +
                           cos(translation_rotation_randomized[6]) * coord1.y,
                       coord1.z,
                       coord1.w);
    }
    else {
      coord2 = coord1;
    }
  }
  else {
    if (translation_rotation_randomized[4] != 0.0) {
      coord1 = vector4(coord2.x,
                       cos(translation_rotation_randomized[4]) * coord2.y -
                           sin(translation_rotation_randomized[4]) * coord2.z,
                       sin(translation_rotation_randomized[4]) * coord2.y +
                           cos(translation_rotation_randomized[4]) * coord2.z,
                       coord2.w);
    }
    else {
      coord1 = coord2;
    }
    if (translation_rotation_randomized[5] != 0.0) {
      coord2 = vector4(cos(translation_rotation_randomized[5]) * coord1.x +
                           sin(translation_rotation_randomized[5]) * coord1.z,
                       coord1.y,
                       cos(translation_rotation_randomized[5]) * coord1.z -
                           sin(translation_rotation_randomized[5]) * coord1.x,
                       coord1.w);
    }
    else {
      coord2 = coord1;
    }
    if (translation_rotation_randomized[6] != 0.0) {
      coord1 = vector4(cos(translation_rotation_randomized[6]) * coord2.x -
                           sin(translation_rotation_randomized[6]) * coord2.y,
                       sin(translation_rotation_randomized[6]) * coord2.x +
                           cos(translation_rotation_randomized[6]) * coord2.y,
                       coord2.z,
                       coord2.w);
    }
    else {
      coord1 = coord2;
    }

    coord2 = vector4(scale_randomized[0],
                     scale_randomized[1],
                     scale_randomized[2],
                     scale_randomized[3]) *
             coord1;
  }

  return coord2;
}

vector4 random_vector4_offset(vector2 seed_offset)
{
  return vector4(100.0, 100.0, 100.0, 100.0) +
         100.0 * vector4(hash_vector3_to_float(vector3(seed_offset.x, seed_offset.y, 1.0)),
                         hash_vector3_to_float(vector3(seed_offset.x, seed_offset.y, 2.0)),
                         hash_vector3_to_float(vector3(seed_offset.x, seed_offset.y, 3.0)),
                         hash_vector3_to_float(vector3(seed_offset.x, seed_offset.y, 4.0)));
}

vector4 random_vector4_offset(vector3 seed_offset)
{
  return vector4(100.0, 100.0, 100.0, 100.0) +
         100.0 * vector4(hash_vector3_to_float(seed_offset + vector3(0.0, 0.0, 1.0)),
                         hash_vector3_to_float(seed_offset + vector3(0.0, 0.0, 2.0)),
                         hash_vector3_to_float(seed_offset + vector3(0.0, 0.0, 3.0)),
                         hash_vector3_to_float(seed_offset + vector3(0.0, 0.0, 4.0)));
}

vector4 random_vector4_offset(vector4 seed_offset)
{
  return vector4(100.0, 100.0, 100.0, 100.0) +
         100.0 * vector4(hash_vector4_to_float(seed_offset + vector4(0.0, 0.0, 1.0, 1.0)),
                         hash_vector4_to_float(seed_offset + vector4(0.0, 0.0, 2.0, 2.0)),
                         hash_vector4_to_float(seed_offset + vector4(0.0, 0.0, 3.0, 3.0)),
                         hash_vector4_to_float(seed_offset + vector4(0.0, 0.0, 4.0, 4.0)));
}

/* Noise Texture fBM optimized for Raiko Texture. */
float raiko_noise_fbm(vector4 coord, float detail, float roughness, float lacunarity)
{
  float octave_scale = 1.0;
  float amplitude = 1.0;
  float max_amplitude = 1.0;
  float sum = 0.0;

  for (int i = 0; i <= int(detail); ++i) {
    sum += amplitude * safe_snoise(octave_scale * coord);
    max_amplitude += amplitude;
    amplitude *= roughness;
    octave_scale *= lacunarity;
  }

  float remainder = detail - floor(detail);
  return (remainder != 0.0) ? ((sum + remainder * amplitude * safe_snoise(octave_scale * coord)) /
                               (max_amplitude + remainder * amplitude)) :
                              (sum / max_amplitude);
}

/* Random offsets are the same as when calling raiko_noise_fbm_layer_1(DeterministicVariables dv,
 * vector4 coord, float seed_offset) with seed_offset == 0.0 */
vector4 raiko_noise_fbm_layer_1(DeterministicVariables dv, vector4 coord)
{
  return vector4(raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     vector4(178.498459, 183.790161, 114.143784, 163.889908),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     vector4(147.634079, 195.179962, 158.144135, 128.116669),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     vector4(195.063629, 144.612671, 155.014709, 165.883881),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     vector4(115.671997, 104.330322, 135.032425, 120.330460),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1));
}

vector4 raiko_noise_fbm_layer_1(DeterministicVariables dv, vector4 coord, float seed_offset)
{
  return vector4(raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(vector2(seed_offset + 1.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(vector2(seed_offset + 2.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(vector2(seed_offset + 3.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(vector2(seed_offset + 4.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1));
}

vector4 raiko_noise_fbm_layer_1(DeterministicVariables dv, vector4 coord, vector2 seed_offset)
{
  return vector4(
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(vector2(seed_offset.x + 1.0, seed_offset.y)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1),
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(vector2(seed_offset.x + 2.0, seed_offset.y)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1),
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(vector2(seed_offset.x + 3.0, seed_offset.y)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1),
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(vector2(seed_offset.x + 4.0, seed_offset.y)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1));
}

vector4 raiko_noise_fbm_layer_1(DeterministicVariables dv, vector4 coord, vector3 seed_offset)
{
  return vector4(raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(seed_offset + vector3(1.0, 0.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(seed_offset + vector3(2.0, 0.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(seed_offset + vector3(3.0, 0.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1),
                 raiko_noise_fbm(dv.noise_scale_1 * coord +
                                     random_vector4_offset(seed_offset + vector3(4.0, 0.0, 0.0)),
                                 dv.noise_detail_1,
                                 dv.noise_roughness_1,
                                 dv.noise_lacunarity_1));
}

vector4 raiko_noise_fbm_layer_1(DeterministicVariables dv, vector4 coord, vector4 seed_offset)
{
  return vector4(
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(seed_offset + vector4(1.0, 0.0, 0.0, 0.0)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1),
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(seed_offset + vector4(2.0, 0.0, 0.0, 0.0)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1),
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(seed_offset + vector4(3.0, 0.0, 0.0, 0.0)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1),
      raiko_noise_fbm(dv.noise_scale_1 * coord +
                          random_vector4_offset(seed_offset + vector4(4.0, 0.0, 0.0, 0.0)),
                      dv.noise_detail_1,
                      dv.noise_roughness_1,
                      dv.noise_lacunarity_1));
}

/* Random offsets are the same as when calling raiko_noise_fbm_layer_2(DeterministicVariables dv,
 * vector4 coord, float seed_offset) with seed_offset == 0.0 */
vector4 raiko_noise_fbm_layer_2(DeterministicVariables dv, vector4 coord)
{
  return vector4(raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     vector4(115.225372, 181.849701, 148.865616, 148.047165),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2),
                 raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     vector4(132.636856, 169.415527, 110.008087, 130.162735),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2),
                 raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     vector4(187.223145, 167.974121, 156.358246, 121.253998),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2),
                 raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     vector4(119.618362, 126.933167, 161.577881, 147.723999),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2));
}

vector4 raiko_noise_fbm_layer_2(DeterministicVariables dv, vector4 coord, float seed_offset)
{
  return vector4(
      raiko_noise_fbm(dv.noise_scale_2 * coord + random_vector4_offset(vector2(seed_offset, 1.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord + random_vector4_offset(vector2(seed_offset, 2.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord + random_vector4_offset(vector2(seed_offset, 3.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord + random_vector4_offset(vector2(seed_offset, 4.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2));
}

vector4 raiko_noise_fbm_layer_2(DeterministicVariables dv, vector4 coord, vector2 seed_offset)
{
  return vector4(
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(vector2(seed_offset.x, seed_offset.y + 1.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(vector2(seed_offset.x, seed_offset.y + 2.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(vector2(seed_offset.x, seed_offset.y + 3.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(vector2(seed_offset.x, seed_offset.y + 4.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2));
}

vector4 raiko_noise_fbm_layer_2(DeterministicVariables dv, vector4 coord, vector3 seed_offset)
{
  return vector4(raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     random_vector4_offset(seed_offset + vector3(0.0, 1.0, 0.0)),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2),
                 raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     random_vector4_offset(seed_offset + vector3(0.0, 2.0, 0.0)),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2),
                 raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     random_vector4_offset(seed_offset + vector3(0.0, 3.0, 0.0)),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2),
                 raiko_noise_fbm(dv.noise_scale_2 * coord +
                                     random_vector4_offset(seed_offset + vector3(0.0, 4.0, 0.0)),
                                 dv.noise_detail_2,
                                 dv.noise_roughness_2,
                                 dv.noise_lacunarity_2));
}

vector4 raiko_noise_fbm_layer_2(DeterministicVariables dv, vector4 coord, vector4 seed_offset)
{
  return vector4(
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(seed_offset + vector4(0.0, 1.0, 0.0, 0.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(seed_offset + vector4(0.0, 2.0, 0.0, 0.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(seed_offset + vector4(0.0, 3.0, 0.0, 0.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2),
      raiko_noise_fbm(dv.noise_scale_2 * coord +
                          random_vector4_offset(seed_offset + vector4(0.0, 4.0, 0.0, 0.0)),
                      dv.noise_detail_2,
                      dv.noise_roughness_2,
                      dv.noise_lacunarity_2));
}

vector4 rotate_noise(vector4 noise_vector, float noise_fragmentation, float index)
{
  float deterministic_angle = noise_fragmentation * M_TAU *
                              (floored_modulo(index + 0.0625, 7.0) +
                               3.0 * floored_modulo(index + 0.0625, 2.0));
  vector4 noise_vector_rotated = vector4(
      cos(deterministic_angle) * noise_vector.x - sin(deterministic_angle) * noise_vector.y,
      sin(deterministic_angle) * noise_vector.x + cos(deterministic_angle) * noise_vector.y,
      cos(deterministic_angle) * noise_vector.z - sin(deterministic_angle) * noise_vector.w,
      sin(deterministic_angle) * noise_vector.z + cos(deterministic_angle) * noise_vector.w);
  float random_angle = noise_fragmentation * M_TAU * 5.0 * hash_float_to_float(index);
  return vector4(
      cos(random_angle) * noise_vector_rotated.x - sin(random_angle) * noise_vector_rotated.z,
      cos(random_angle) * noise_vector_rotated.y - sin(random_angle) * noise_vector_rotated.w,
      sin(random_angle) * noise_vector_rotated.x + cos(random_angle) * noise_vector_rotated.z,
      sin(random_angle) * noise_vector_rotated.y + cos(random_angle) * noise_vector_rotated.w);
}

vector4 rotate_noise(vector4 noise_vector, float noise_fragmentation, vector2 index)
{
  float deterministic_angle = noise_fragmentation * M_TAU *
                              (floored_modulo(index.x + 0.0625, 7.0) +
                               3.0 * floored_modulo(index.x + 0.0625, 2.0) +
                               13.0 * (floored_modulo(index.y + 0.0625, 7.0) +
                                       3.0 * floored_modulo(index.y + 0.0625, 2.0)));
  vector4 noise_vector_rotated = vector4(
      cos(deterministic_angle) * noise_vector.x - sin(deterministic_angle) * noise_vector.y,
      sin(deterministic_angle) * noise_vector.x + cos(deterministic_angle) * noise_vector.y,
      cos(deterministic_angle) * noise_vector.z - sin(deterministic_angle) * noise_vector.w,
      sin(deterministic_angle) * noise_vector.z + cos(deterministic_angle) * noise_vector.w);
  float random_angle = noise_fragmentation * M_TAU * 5.0 * hash_vector2_to_float(index);
  return vector4(
      cos(random_angle) * noise_vector_rotated.x - sin(random_angle) * noise_vector_rotated.z,
      cos(random_angle) * noise_vector_rotated.y - sin(random_angle) * noise_vector_rotated.w,
      sin(random_angle) * noise_vector_rotated.x + cos(random_angle) * noise_vector_rotated.z,
      sin(random_angle) * noise_vector_rotated.y + cos(random_angle) * noise_vector_rotated.w);
}

vector4 rotate_noise(vector4 noise_vector, float noise_fragmentation, vector3 index)
{
  float deterministic_angle = noise_fragmentation * M_TAU *
                              (floored_modulo(index.x + 0.0625, 7.0) +
                               3.0 * floored_modulo(index.x + 0.0625, 2.0) +
                               13.0 * (floored_modulo(index.y + 0.0625, 7.0) +
                                       3.0 * floored_modulo(index.y + 0.0625, 2.0)) +
                               143.0 * (floored_modulo(index.z + 0.0625, 7.0) +
                                        3.0 * floored_modulo(index.z + 0.0625, 2.0)));
  vector4 noise_vector_rotated = vector4(
      cos(deterministic_angle) * noise_vector.x - sin(deterministic_angle) * noise_vector.y,
      sin(deterministic_angle) * noise_vector.x + cos(deterministic_angle) * noise_vector.y,
      cos(deterministic_angle) * noise_vector.z - sin(deterministic_angle) * noise_vector.w,
      sin(deterministic_angle) * noise_vector.z + cos(deterministic_angle) * noise_vector.w);
  float random_angle = noise_fragmentation * M_TAU * 5.0 * hash_vector3_to_float(index);
  return vector4(
      cos(random_angle) * noise_vector_rotated.x - sin(random_angle) * noise_vector_rotated.z,
      cos(random_angle) * noise_vector_rotated.y - sin(random_angle) * noise_vector_rotated.w,
      sin(random_angle) * noise_vector_rotated.x + cos(random_angle) * noise_vector_rotated.z,
      sin(random_angle) * noise_vector_rotated.y + cos(random_angle) * noise_vector_rotated.w);
}

vector4 rotate_noise(vector4 noise_vector, float noise_fragmentation, vector4 index)
{
  float deterministic_angle = noise_fragmentation * M_TAU *
                              (floored_modulo(index.x + 0.0625, 7.0) +
                               3.0 * floored_modulo(index.x + 0.0625, 2.0) +
                               13.0 * (floored_modulo(index.y + 0.0625, 7.0) +
                                       3.0 * floored_modulo(index.y + 0.0625, 2.0)) +
                               143.0 * (floored_modulo(index.z + 0.0625, 7.0) +
                                        3.0 * floored_modulo(index.z + 0.0625, 2.0)) +
                               2431.0 * (floored_modulo(index.w + 0.0625, 7.0) +
                                         3.0 * floored_modulo(index.w + 0.0625, 2.0)));
  vector4 noise_vector_rotated = vector4(
      cos(deterministic_angle) * noise_vector.x - sin(deterministic_angle) * noise_vector.y,
      sin(deterministic_angle) * noise_vector.x + cos(deterministic_angle) * noise_vector.y,
      cos(deterministic_angle) * noise_vector.z - sin(deterministic_angle) * noise_vector.w,
      sin(deterministic_angle) * noise_vector.z + cos(deterministic_angle) * noise_vector.w);
  float random_angle = noise_fragmentation * M_TAU * 5.0 * hash_vector4_to_float(index);
  return vector4(
      cos(random_angle) * noise_vector_rotated.x - sin(random_angle) * noise_vector_rotated.z,
      cos(random_angle) * noise_vector_rotated.y - sin(random_angle) * noise_vector_rotated.w,
      sin(random_angle) * noise_vector_rotated.x + cos(random_angle) * noise_vector_rotated.z,
      sin(random_angle) * noise_vector_rotated.y + cos(random_angle) * noise_vector_rotated.w);
}

OutVariables raiko_select_mode_0d(DeterministicVariables dv,
                                  float r_sphere[],
                                  float r_sphere_min[],
                                  float r_sphere_max[],
                                  int r_sphere_index_list[],
                                  int r_sphere_index_count,
                                  float translation_rotation[],
                                  float translation_rotation_min[],
                                  float translation_rotation_max[],
                                  int translation_rotation_index_list[],
                                  int translation_rotation_index_count,
                                  float scale[],
                                  float scale_randomness[],
                                  int scale_index_list[],
                                  int scale_index_count,
                                  float remap[],
                                  float remap_min[],
                                  float remap_max[],
                                  int remap_index_list[],
                                  int remap_index_count)
{
  OutVariables ov;
  vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
  if (dv.calculate_fields_noise_1) {
    if (dv.transform_fields_noise) {
      fields_noise_layer_1 = raiko_noise_fbm_layer_1(
          dv,
          rotate_scale(dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
    }
    else {
      fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
    }
  }
  vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
  if (dv.calculate_fields_noise_2) {
    if (dv.transform_fields_noise) {
      fields_noise_layer_2 = raiko_noise_fbm_layer_2(
          dv,
          rotate_scale(dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
    }
    else {
      fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
    }
  }
  vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                dv.noise_fields_strength_2 * fields_noise_layer_2;

  float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
  randomize_float_array(r_sphere_randomized,
                        r_sphere_min,
                        r_sphere_max,
                        r_sphere_index_list,
                        r_sphere_index_count,
                        0.0);
  float translation_rotation_randomized[7];
  for (int n = 0; n < 7; ++n) {
    translation_rotation_randomized[n] = translation_rotation[n];
  }
  randomize_float_array(translation_rotation_randomized,
                        translation_rotation_min,
                        translation_rotation_max,
                        translation_rotation_index_list,
                        translation_rotation_index_count,
                        0.0);
  float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
  randomize_scale(scale_randomized,
                  scale_randomness,
                  scale_index_list,
                  scale_index_count,
                  dv.uniform_scale_randomness,
                  0.0);

  vector4 iteration_position = vector4(translation_rotation_randomized[0],
                                       translation_rotation_randomized[1],
                                       translation_rotation_randomized[2],
                                       translation_rotation_randomized[3]);
  vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                         translation_rotation_randomized,
                                         scale_randomized,
                                         dv.invert_order_of_transformation);
  vector4 iteration_coord;
  if (dv.noise_fragmentation_non_zero) {
    iteration_coord = noiseless_coord +
                      rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
  }
  else {
    iteration_coord = noiseless_coord + fields_noise_vector;
  }

  if (dv.mode == "additive") {
    ov.out_r_sphere_field = chained_elliptical_remap_select_steps(
        dv.step_count,
        remap,
        remap_min,
        remap_max,
        remap_index_list,
        remap_index_count,
        0.0,
        calculate_l_angle_bisector_4d(dv.integer_sides,
                                      dv.elliptical_corners,
                                      r_sphere_randomized[0],
                                      r_sphere_randomized[1],
                                      r_sphere_randomized[2],
                                      r_sphere_randomized[3],
                                      iteration_coord));
  }
  else {
    vector4 coordinates_noise_layer_1 = fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_layer_2 = fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                           coordinates_noise_layer_1 +
                                       dv.noise_coordinates_strength_2 * coordinates_noise_layer_2;

    vector4 iteration_r_sphere_coordinates;
    if (dv.noise_fragmentation_non_zero) {
      iteration_r_sphere_coordinates = noiseless_coord + rotate_noise(coordinates_noise_vector,
                                                                      dv.noise_fragmentation,
                                                                      0.0);
    }
    else {
      iteration_r_sphere_coordinates = noiseless_coord + coordinates_noise_vector;
    }

    vector4 out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                                 dv.calculate_r_gon_parameter_field,
                                                 dv.calculate_max_unit_parameter_field,
                                                 dv.normalize_r_gon_parameter,
                                                 dv.integer_sides,
                                                 dv.elliptical_corners,
                                                 r_sphere_randomized[0],
                                                 r_sphere_randomized[1],
                                                 r_sphere_randomized[2],
                                                 r_sphere_randomized[3],
                                                 iteration_coord);

    ov.out_r_sphere_field = out_fields.x;
    ov.r_gon_parameter_field = out_fields.y;
    ov.max_unit_parameter_field = out_fields.z;
    ov.segment_id_field = out_fields.w;
    ov.out_r_sphere_coordinates = iteration_r_sphere_coordinates;
  }
  return ov;
}

OutVariables raiko_select_mode_1d(DeterministicVariables dv,
                                  float r_sphere[],
                                  float r_sphere_min[],
                                  float r_sphere_max[],
                                  int r_sphere_index_list[],
                                  int r_sphere_index_count,
                                  float translation_rotation[],
                                  float translation_rotation_min[],
                                  float translation_rotation_max[],
                                  int translation_rotation_index_list[],
                                  int translation_rotation_index_count,
                                  float scale[],
                                  float scale_randomness[],
                                  int scale_index_list[],
                                  int scale_index_count,
                                  float remap[],
                                  float remap_min[],
                                  float remap_max[],
                                  int remap_index_list[],
                                  int remap_index_count,
                                  vector4 initial_index,
                                  vector4 initial_position)
{
  float scanning_window_size = ceil(4.0 * dv.accuracy);
  OutVariables ov;
  if (dv.mode == "additive") {
    ov.out_r_sphere_field = 0.0;
    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;

    for (float i = -scanning_window_size; i <= scanning_window_size; ++i) {
      float iteration_index = i + initial_index.x;
      float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
      randomize_float_array(r_sphere_randomized,
                            r_sphere_min,
                            r_sphere_max,
                            r_sphere_index_list,
                            r_sphere_index_count,
                            5.0 * iteration_index);
      float translation_rotation_randomized[7];
      for (int n = 0; n < 7; ++n) {
        translation_rotation_randomized[n] = translation_rotation[n];
      }
      randomize_float_array(translation_rotation_randomized,
                            translation_rotation_min,
                            translation_rotation_max,
                            translation_rotation_index_list,
                            translation_rotation_index_count,
                            8.0 * iteration_index);
      float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
      randomize_scale(scale_randomized,
                      scale_randomness,
                      scale_index_list,
                      scale_index_count,
                      dv.uniform_scale_randomness,
                      9.0 * iteration_index);

      vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                   vector4(translation_rotation_randomized[0],
                                           translation_rotation_randomized[1],
                                           translation_rotation_randomized[2],
                                           translation_rotation_randomized[3]);
      vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                             translation_rotation_randomized,
                                             scale_randomized,
                                             dv.invert_order_of_transformation);
      vector4 iteration_coord;
      if (dv.noise_fragmentation_non_zero) {
        iteration_coord = noiseless_coord +
                          rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
      }
      else {
        iteration_coord = noiseless_coord + fields_noise_vector;
      }

      ov.out_r_sphere_field += chained_elliptical_remap_select_steps(
          dv.step_count,
          remap,
          remap_min,
          remap_max,
          remap_index_list,
          remap_index_count,
          27.0 * iteration_index,
          calculate_l_angle_bisector_4d(dv.integer_sides,
                                        dv.elliptical_corners,
                                        r_sphere_randomized[0],
                                        r_sphere_randomized[1],
                                        r_sphere_randomized[2],
                                        r_sphere_randomized[3],
                                        iteration_coord));
    }
  }
  else if (dv.mode == "closest") {
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    float min_distance = FLT_MAX;
    float closest_rotation_randomized[7];
    float closest_scale_randomized[4];
    vector4 index_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 index_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 index_noise_vector = dv.noise_fields_strength_1 * index_noise_layer_1 +
                                 dv.noise_fields_strength_2 * index_noise_layer_2;

    for (float i = -scanning_window_size; i <= scanning_window_size; ++i) {
      float iteration_index = i + initial_index.x;
      float translation_rotation_randomized[7];
      for (int n = 0; n < 7; ++n) {
        translation_rotation_randomized[n] = translation_rotation[n];
      }
      randomize_float_array(translation_rotation_randomized,
                            translation_rotation_min,
                            translation_rotation_max,
                            translation_rotation_index_list,
                            translation_rotation_index_count,
                            8.0 * iteration_index);
      float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
      randomize_scale(scale_randomized,
                      scale_randomness,
                      scale_index_list,
                      scale_index_count,
                      dv.uniform_scale_randomness,
                      9.0 * iteration_index);

      vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                   vector4(translation_rotation_randomized[0],
                                           translation_rotation_randomized[1],
                                           translation_rotation_randomized[2],
                                           translation_rotation_randomized[3]);
      vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                             translation_rotation_randomized,
                                             scale_randomized,
                                             dv.invert_order_of_transformation);
      vector4 iteration_coord;
      if (dv.noise_fragmentation_non_zero) {
        iteration_coord = noiseless_coord +
                          rotate_noise(index_noise_vector, dv.noise_fragmentation, 0.0);
      }
      else {
        iteration_coord = noiseless_coord + index_noise_vector;
      }

      float l_iteration_coord = euclidean_norm(iteration_coord);
      if (l_iteration_coord < min_distance) {
        min_distance = l_iteration_coord;
        ov.out_index_field.x = iteration_index;
        ov.out_position_field = iteration_position;
        /* Translation data not needed for subsequent computations. */
        closest_rotation_randomized[4] = translation_rotation_randomized[4];
        closest_rotation_randomized[5] = translation_rotation_randomized[5];
        closest_rotation_randomized[6] = translation_rotation_randomized[6];
        closest_scale_randomized[0] = scale_randomized[0];
        closest_scale_randomized[1] = scale_randomized[1];
        closest_scale_randomized[2] = scale_randomized[2];
        closest_scale_randomized[3] = scale_randomized[3];
      }
    }

    vector4 closest_fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field.x);
      }
      else {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field.x);
      }
    }
    vector4 closest_fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field.x);
      }
      else {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field.x);
      }
    }
    vector4 closest_fields_noise_vector = dv.noise_fields_strength_1 *
                                              closest_fields_noise_layer_1 +
                                          dv.noise_fields_strength_2 *
                                              closest_fields_noise_layer_2;
    vector4 closest_coordinates_noise_layer_1 = closest_fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field.x);
      }
      else {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field.x);
      }
    }
    vector4 closest_coordinates_noise_layer_2 = closest_fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field.x);
      }
      else {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field.x);
      }
    }
    vector4 closest_coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                                   closest_coordinates_noise_layer_1 +
                                               dv.noise_coordinates_strength_2 *
                                                   closest_coordinates_noise_layer_2;

    vector4 noiseless_coord = rotate_scale(dv.coord - ov.out_position_field,
                                           closest_rotation_randomized,
                                           closest_scale_randomized,
                                           dv.invert_order_of_transformation);
    if (dv.noise_fragmentation_non_zero) {
      ov.out_r_sphere_coordinates = noiseless_coord +
                                    rotate_noise(closest_coordinates_noise_vector,
                                                 dv.noise_fragmentation,
                                                 7.0 * ov.out_index_field.x);
    }
    else {
      ov.out_r_sphere_coordinates = noiseless_coord + closest_coordinates_noise_vector;
    }

    float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
    randomize_float_array(r_sphere_randomized,
                          r_sphere_min,
                          r_sphere_max,
                          r_sphere_index_list,
                          r_sphere_index_count,
                          5.0 * ov.out_index_field.x);

    vector4 out_fields;
    if (dv.noise_fragmentation_non_zero) {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord +
                                               rotate_noise(closest_fields_noise_vector,
                                                            dv.noise_fragmentation,
                                                            7.0 * ov.out_index_field.x));
    }
    else {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord + closest_fields_noise_vector);
    }
    ov.out_r_sphere_field = out_fields.x;
    ov.r_gon_parameter_field = out_fields.y;
    ov.max_unit_parameter_field = out_fields.z;
    ov.segment_id_field = out_fields.w;
  }
  else {
    ov.out_r_sphere_field = 0.0;
    ov.r_gon_parameter_field = 0.0;
    ov.max_unit_parameter_field = 0.0;
    ov.segment_id_field = 0.0;
    ov.out_r_sphere_coordinates = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_position_field = vector4(0.0, 0.0, 0.0, 0.0);
    int first_iteration = 1;

    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;
    vector4 coordinates_noise_layer_1 = fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_layer_2 = fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                           coordinates_noise_layer_1 +
                                       dv.noise_coordinates_strength_2 * coordinates_noise_layer_2;

    for (float i = -scanning_window_size; i <= scanning_window_size; ++i) {
      float iteration_index = i + initial_index.x;
      float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
      randomize_float_array(r_sphere_randomized,
                            r_sphere_min,
                            r_sphere_max,
                            r_sphere_index_list,
                            r_sphere_index_count,
                            5.0 * iteration_index);
      float translation_rotation_randomized[7];
      for (int n = 0; n < 7; ++n) {
        translation_rotation_randomized[n] = translation_rotation[n];
      }
      randomize_float_array(translation_rotation_randomized,
                            translation_rotation_min,
                            translation_rotation_max,
                            translation_rotation_index_list,
                            translation_rotation_index_count,
                            8.0 * iteration_index);
      float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
      randomize_scale(scale_randomized,
                      scale_randomness,
                      scale_index_list,
                      scale_index_count,
                      dv.uniform_scale_randomness,
                      9.0 * iteration_index);

      vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                   vector4(translation_rotation_randomized[0],
                                           translation_rotation_randomized[1],
                                           translation_rotation_randomized[2],
                                           translation_rotation_randomized[3]);
      vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                             translation_rotation_randomized,
                                             scale_randomized,
                                             dv.invert_order_of_transformation);
      vector4 iteration_coord;
      if (dv.noise_fragmentation_non_zero) {
        iteration_coord = noiseless_coord +
                          rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
      }
      else {
        iteration_coord = noiseless_coord + fields_noise_vector;
      }
      vector4 iteration_r_sphere_coordinates;
      if (dv.noise_fragmentation_non_zero) {
        iteration_r_sphere_coordinates = noiseless_coord + rotate_noise(coordinates_noise_vector,
                                                                        dv.noise_fragmentation,
                                                                        0.0);
      }
      else {
        iteration_r_sphere_coordinates = noiseless_coord + coordinates_noise_vector;
      }

      vector4 out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                                   dv.calculate_r_gon_parameter_field,
                                                   dv.calculate_max_unit_parameter_field,
                                                   dv.normalize_r_gon_parameter,
                                                   dv.integer_sides,
                                                   dv.elliptical_corners,
                                                   r_sphere_randomized[0],
                                                   r_sphere_randomized[1],
                                                   r_sphere_randomized[2],
                                                   r_sphere_randomized[3],
                                                   iteration_coord);
      float iteration_l_angle_bisector_4d = out_fields.x;
      float iteration_r_gon_parameter = out_fields.y;
      float iteration_max_unit_parameter = out_fields.z;
      float iteration_segment_id = out_fields.w;

      if (dv.smoothness_non_zero) {
        float interpolation_factor =
            first_iteration ?
                1.0 :
                smoothstep(0.0,
                           1.0,
                           0.5 + 0.5 * (ov.out_r_sphere_field - iteration_l_angle_bisector_4d) /
                                     dv.smoothness);
        float substraction_factor = dv.smoothness * interpolation_factor *
                                    (1.0 - interpolation_factor);
        ov.out_r_sphere_field = mix(ov.out_r_sphere_field,
                                    iteration_l_angle_bisector_4d,
                                    interpolation_factor) -
                                substraction_factor;

        ov.r_gon_parameter_field = mix(
            ov.r_gon_parameter_field, iteration_r_gon_parameter, interpolation_factor);
        ov.max_unit_parameter_field = mix(
            ov.max_unit_parameter_field, iteration_max_unit_parameter, interpolation_factor);
        ov.segment_id_field = mix(ov.segment_id_field, iteration_segment_id, interpolation_factor);
        ov.out_index_field.x = mix(ov.out_index_field.x, iteration_index, interpolation_factor);
        ov.out_position_field = mix(
            ov.out_position_field, iteration_position, interpolation_factor);
        ov.out_r_sphere_coordinates = mix(
            ov.out_r_sphere_coordinates, iteration_r_sphere_coordinates, interpolation_factor);
      }
      else if ((iteration_l_angle_bisector_4d < ov.out_r_sphere_field) || first_iteration) {
        ov.out_r_sphere_field = iteration_l_angle_bisector_4d;
        ov.r_gon_parameter_field = iteration_r_gon_parameter;
        ov.max_unit_parameter_field = iteration_max_unit_parameter;
        ov.segment_id_field = iteration_segment_id;
        ov.out_index_field.x = iteration_index;
        ov.out_position_field = iteration_position;
        ov.out_r_sphere_coordinates = iteration_r_sphere_coordinates;
      }
      first_iteration = 0;
    }
  }
  return ov;
}

OutVariables raiko_select_mode_2d(DeterministicVariables dv,
                                  float r_sphere[],
                                  float r_sphere_min[],
                                  float r_sphere_max[],
                                  int r_sphere_index_list[],
                                  int r_sphere_index_count,
                                  float translation_rotation[],
                                  float translation_rotation_min[],
                                  float translation_rotation_max[],
                                  int translation_rotation_index_list[],
                                  int translation_rotation_index_count,
                                  float scale[],
                                  float scale_randomness[],
                                  int scale_index_list[],
                                  int scale_index_count,
                                  float remap[],
                                  float remap_min[],
                                  float remap_max[],
                                  int remap_index_list[],
                                  int remap_index_count,
                                  vector4 initial_index,
                                  vector4 initial_position)
{
  float l_grid_vector1 = euclidean_norm(dv.grid_vector_1);
  float l_grid_vector2 = euclidean_norm(dv.grid_vector_2);
  float l_shortest_grid_vector = min(l_grid_vector1, l_grid_vector2);
  vector2 scanning_window_size = ceil(
      4.0 * dv.accuracy *
      vector2(l_shortest_grid_vector / l_grid_vector1, l_shortest_grid_vector / l_grid_vector2));
  OutVariables ov;
  if (dv.mode == "additive") {
    ov.out_r_sphere_field = 0.0;
    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;

    for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
      for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
        vector2 iteration_index = vector2(i, j) + vector2(initial_index.x, initial_index.y);
        float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
        randomize_float_array(r_sphere_randomized,
                              r_sphere_min,
                              r_sphere_max,
                              r_sphere_index_list,
                              r_sphere_index_count,
                              5.0 * iteration_index);
        float translation_rotation_randomized[7];
        for (int n = 0; n < 7; ++n) {
          translation_rotation_randomized[n] = translation_rotation[n];
        }
        randomize_float_array(translation_rotation_randomized,
                              translation_rotation_min,
                              translation_rotation_max,
                              translation_rotation_index_list,
                              translation_rotation_index_count,
                              8.0 * iteration_index);
        float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
        randomize_scale(scale_randomized,
                        scale_randomness,
                        scale_index_list,
                        scale_index_count,
                        dv.uniform_scale_randomness,
                        9.0 * iteration_index);

        vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                     j * dv.grid_vector_2 +
                                     vector4(translation_rotation_randomized[0],
                                             translation_rotation_randomized[1],
                                             translation_rotation_randomized[2],
                                             translation_rotation_randomized[3]);
        vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                               translation_rotation_randomized,
                                               scale_randomized,
                                               dv.invert_order_of_transformation);
        vector4 iteration_coord;
        if (dv.noise_fragmentation_non_zero) {
          iteration_coord = noiseless_coord +
                            rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
        }
        else {
          iteration_coord = noiseless_coord + fields_noise_vector;
        }

        ov.out_r_sphere_field += chained_elliptical_remap_select_steps(
            dv.step_count,
            remap,
            remap_min,
            remap_max,
            remap_index_list,
            remap_index_count,
            27.0 * iteration_index,
            calculate_l_angle_bisector_4d(dv.integer_sides,
                                          dv.elliptical_corners,
                                          r_sphere_randomized[0],
                                          r_sphere_randomized[1],
                                          r_sphere_randomized[2],
                                          r_sphere_randomized[3],
                                          iteration_coord));
      }
    }
  }
  else if (dv.mode == "closest") {
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    float min_distance = FLT_MAX;
    float closest_rotation_randomized[7];
    float closest_scale_randomized[4];
    vector4 index_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 index_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 index_noise_vector = dv.noise_fields_strength_1 * index_noise_layer_1 +
                                 dv.noise_fields_strength_2 * index_noise_layer_2;

    for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
      for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
        vector2 iteration_index = vector2(i, j) + vector2(initial_index.x, initial_index.y);
        float translation_rotation_randomized[7];
        for (int n = 0; n < 7; ++n) {
          translation_rotation_randomized[n] = translation_rotation[n];
        }
        randomize_float_array(translation_rotation_randomized,
                              translation_rotation_min,
                              translation_rotation_max,
                              translation_rotation_index_list,
                              translation_rotation_index_count,
                              8.0 * iteration_index);
        float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
        randomize_scale(scale_randomized,
                        scale_randomness,
                        scale_index_list,
                        scale_index_count,
                        dv.uniform_scale_randomness,
                        9.0 * iteration_index);

        vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                     j * dv.grid_vector_2 +
                                     vector4(translation_rotation_randomized[0],
                                             translation_rotation_randomized[1],
                                             translation_rotation_randomized[2],
                                             translation_rotation_randomized[3]);
        vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                               translation_rotation_randomized,
                                               scale_randomized,
                                               dv.invert_order_of_transformation);
        vector4 iteration_coord;
        if (dv.noise_fragmentation_non_zero) {
          iteration_coord = noiseless_coord +
                            rotate_noise(index_noise_vector, dv.noise_fragmentation, 0.0);
        }
        else {
          iteration_coord = noiseless_coord + index_noise_vector;
        }

        float l_iteration_coord = euclidean_norm(iteration_coord);
        if (l_iteration_coord < min_distance) {
          min_distance = l_iteration_coord;
          ov.out_index_field.x = iteration_index.x;
          ov.out_index_field.y = iteration_index.y;
          ov.out_position_field = iteration_position;
          /* Translation data not needed for subsequent computations. */
          closest_rotation_randomized[4] = translation_rotation_randomized[4];
          closest_rotation_randomized[5] = translation_rotation_randomized[5];
          closest_rotation_randomized[6] = translation_rotation_randomized[6];
          closest_scale_randomized[0] = scale_randomized[0];
          closest_scale_randomized[1] = scale_randomized[1];
          closest_scale_randomized[2] = scale_randomized[2];
          closest_scale_randomized[3] = scale_randomized[3];
        }
      }
    }

    vector4 closest_fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
      else {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
    }
    vector4 closest_fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
      else {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
    }
    vector4 closest_fields_noise_vector = dv.noise_fields_strength_1 *
                                              closest_fields_noise_layer_1 +
                                          dv.noise_fields_strength_2 *
                                              closest_fields_noise_layer_2;
    vector4 closest_coordinates_noise_layer_1 = closest_fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
      else {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
    }
    vector4 closest_coordinates_noise_layer_2 = closest_fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
      else {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
      }
    }
    vector4 closest_coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                                   closest_coordinates_noise_layer_1 +
                                               dv.noise_coordinates_strength_2 *
                                                   closest_coordinates_noise_layer_2;

    vector4 noiseless_coord = rotate_scale(dv.coord - ov.out_position_field,
                                           closest_rotation_randomized,
                                           closest_scale_randomized,
                                           dv.invert_order_of_transformation);
    if (dv.noise_fragmentation_non_zero) {
      ov.out_r_sphere_coordinates = noiseless_coord +
                                    rotate_noise(
                                        closest_coordinates_noise_vector,
                                        dv.noise_fragmentation,
                                        7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));
    }
    else {
      ov.out_r_sphere_coordinates = noiseless_coord + closest_coordinates_noise_vector;
    }

    float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
    randomize_float_array(r_sphere_randomized,
                          r_sphere_min,
                          r_sphere_max,
                          r_sphere_index_list,
                          r_sphere_index_count,
                          5.0 * vector2(ov.out_index_field.x, ov.out_index_field.y));

    vector4 out_fields;
    if (dv.noise_fragmentation_non_zero) {
      out_fields = calculate_out_fields_4d(
          dv.calculate_r_sphere_field,
          dv.calculate_r_gon_parameter_field,
          dv.calculate_max_unit_parameter_field,
          dv.normalize_r_gon_parameter,
          dv.integer_sides,
          dv.elliptical_corners,
          r_sphere_randomized[0],
          r_sphere_randomized[1],
          r_sphere_randomized[2],
          r_sphere_randomized[3],
          noiseless_coord +
              rotate_noise(closest_fields_noise_vector,
                           dv.noise_fragmentation,
                           7.0 * vector2(ov.out_index_field.x, ov.out_index_field.y)));
    }
    else {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord + closest_fields_noise_vector);
    }
    ov.out_r_sphere_field = out_fields.x;
    ov.r_gon_parameter_field = out_fields.y;
    ov.max_unit_parameter_field = out_fields.z;
    ov.segment_id_field = out_fields.w;
  }
  else {
    ov.out_r_sphere_field = 0.0;
    ov.r_gon_parameter_field = 0.0;
    ov.max_unit_parameter_field = 0.0;
    ov.segment_id_field = 0.0;
    ov.out_r_sphere_coordinates = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_position_field = vector4(0.0, 0.0, 0.0, 0.0);
    int first_iteration = 1;

    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;
    vector4 coordinates_noise_layer_1 = fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_layer_2 = fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                           coordinates_noise_layer_1 +
                                       dv.noise_coordinates_strength_2 * coordinates_noise_layer_2;

    for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
      for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
        vector2 iteration_index = vector2(i, j) + vector2(initial_index.x, initial_index.y);
        float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
        randomize_float_array(r_sphere_randomized,
                              r_sphere_min,
                              r_sphere_max,
                              r_sphere_index_list,
                              r_sphere_index_count,
                              5.0 * iteration_index);
        float translation_rotation_randomized[7];
        for (int n = 0; n < 7; ++n) {
          translation_rotation_randomized[n] = translation_rotation[n];
        }
        randomize_float_array(translation_rotation_randomized,
                              translation_rotation_min,
                              translation_rotation_max,
                              translation_rotation_index_list,
                              translation_rotation_index_count,
                              8.0 * iteration_index);
        float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
        randomize_scale(scale_randomized,
                        scale_randomness,
                        scale_index_list,
                        scale_index_count,
                        dv.uniform_scale_randomness,
                        9.0 * iteration_index);

        vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                     j * dv.grid_vector_2 +
                                     vector4(translation_rotation_randomized[0],
                                             translation_rotation_randomized[1],
                                             translation_rotation_randomized[2],
                                             translation_rotation_randomized[3]);
        vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                               translation_rotation_randomized,
                                               scale_randomized,
                                               dv.invert_order_of_transformation);
        vector4 iteration_coord;
        if (dv.noise_fragmentation_non_zero) {
          iteration_coord = noiseless_coord +
                            rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
        }
        else {
          iteration_coord = noiseless_coord + fields_noise_vector;
        }
        vector4 iteration_r_sphere_coordinates;
        if (dv.noise_fragmentation_non_zero) {
          iteration_r_sphere_coordinates = noiseless_coord + rotate_noise(coordinates_noise_vector,
                                                                          dv.noise_fragmentation,
                                                                          0.0);
        }
        else {
          iteration_r_sphere_coordinates = noiseless_coord + coordinates_noise_vector;
        }

        vector4 out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                                     dv.calculate_r_gon_parameter_field,
                                                     dv.calculate_max_unit_parameter_field,
                                                     dv.normalize_r_gon_parameter,
                                                     dv.integer_sides,
                                                     dv.elliptical_corners,
                                                     r_sphere_randomized[0],
                                                     r_sphere_randomized[1],
                                                     r_sphere_randomized[2],
                                                     r_sphere_randomized[3],
                                                     iteration_coord);
        float iteration_l_angle_bisector_4d = out_fields.x;
        float iteration_r_gon_parameter = out_fields.y;
        float iteration_max_unit_parameter = out_fields.z;
        float iteration_segment_id = out_fields.w;

        if (dv.smoothness_non_zero) {
          float interpolation_factor =
              first_iteration ?
                  1.0 :
                  smoothstep(0.0,
                             1.0,
                             0.5 + 0.5 * (ov.out_r_sphere_field - iteration_l_angle_bisector_4d) /
                                       dv.smoothness);
          float substraction_factor = dv.smoothness * interpolation_factor *
                                      (1.0 - interpolation_factor);
          ov.out_r_sphere_field = mix(ov.out_r_sphere_field,
                                      iteration_l_angle_bisector_4d,
                                      interpolation_factor) -
                                  substraction_factor;

          ov.r_gon_parameter_field = mix(
              ov.r_gon_parameter_field, iteration_r_gon_parameter, interpolation_factor);
          ov.max_unit_parameter_field = mix(
              ov.max_unit_parameter_field, iteration_max_unit_parameter, interpolation_factor);
          ov.segment_id_field = mix(
              ov.segment_id_field, iteration_segment_id, interpolation_factor);
          ov.out_index_field.x = mix(
              ov.out_index_field.x, iteration_index.x, interpolation_factor);
          ov.out_index_field.y = mix(
              ov.out_index_field.y, iteration_index.y, interpolation_factor);
          ov.out_position_field = mix(
              ov.out_position_field, iteration_position, interpolation_factor);
          ov.out_r_sphere_coordinates = mix(
              ov.out_r_sphere_coordinates, iteration_r_sphere_coordinates, interpolation_factor);
        }
        else if ((iteration_l_angle_bisector_4d < ov.out_r_sphere_field) || first_iteration) {
          ov.out_r_sphere_field = iteration_l_angle_bisector_4d;
          ov.r_gon_parameter_field = iteration_r_gon_parameter;
          ov.max_unit_parameter_field = iteration_max_unit_parameter;
          ov.segment_id_field = iteration_segment_id;
          ov.out_index_field.x = iteration_index.x;
          ov.out_index_field.y = iteration_index.y;
          ov.out_position_field = iteration_position;
          ov.out_r_sphere_coordinates = iteration_r_sphere_coordinates;
        }
        first_iteration = 0;
      }
    }
  }
  return ov;
}

OutVariables raiko_select_mode_3d(DeterministicVariables dv,
                                  float r_sphere[],
                                  float r_sphere_min[],
                                  float r_sphere_max[],
                                  int r_sphere_index_list[],
                                  int r_sphere_index_count,
                                  float translation_rotation[],
                                  float translation_rotation_min[],
                                  float translation_rotation_max[],
                                  int translation_rotation_index_list[],
                                  int translation_rotation_index_count,
                                  float scale[],
                                  float scale_randomness[],
                                  int scale_index_list[],
                                  int scale_index_count,
                                  float remap[],
                                  float remap_min[],
                                  float remap_max[],
                                  int remap_index_list[],
                                  int remap_index_count,
                                  vector4 initial_index,
                                  vector4 initial_position)
{
  float l_grid_vector1 = euclidean_norm(dv.grid_vector_1);
  float l_grid_vector2 = euclidean_norm(dv.grid_vector_2);
  float l_grid_vector3 = euclidean_norm(dv.grid_vector_3);
  float l_shortest_grid_vector = min(l_grid_vector1, min(l_grid_vector2, l_grid_vector3));
  vector3 scanning_window_size = ceil(4.0 * dv.accuracy *
                                      vector3(l_shortest_grid_vector / l_grid_vector1,
                                              l_shortest_grid_vector / l_grid_vector2,
                                              l_shortest_grid_vector / l_grid_vector3));
  OutVariables ov;
  if (dv.mode == "additive") {
    ov.out_r_sphere_field = 0.0;
    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;

    for (float k = -scanning_window_size.z; k <= scanning_window_size.z; ++k) {
      for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
        for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
          vector3 iteration_index = vector3(i, j, k) +
                                    vector3(initial_index.x, initial_index.y, initial_index.z);
          float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
          randomize_float_array(r_sphere_randomized,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                5.0 * iteration_index);
          float translation_rotation_randomized[7];
          for (int n = 0; n < 7; ++n) {
            translation_rotation_randomized[n] = translation_rotation[n];
          }
          randomize_float_array(translation_rotation_randomized,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                8.0 * iteration_index);
          float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
          randomize_scale(scale_randomized,
                          scale_randomness,
                          scale_index_list,
                          scale_index_count,
                          dv.uniform_scale_randomness,
                          9.0 * iteration_index);

          vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                       j * dv.grid_vector_2 + k * dv.grid_vector_3 +
                                       vector4(translation_rotation_randomized[0],
                                               translation_rotation_randomized[1],
                                               translation_rotation_randomized[2],
                                               translation_rotation_randomized[3]);
          vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                                 translation_rotation_randomized,
                                                 scale_randomized,
                                                 dv.invert_order_of_transformation);
          vector4 iteration_coord;
          if (dv.noise_fragmentation_non_zero) {
            iteration_coord = noiseless_coord +
                              rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
          }
          else {
            iteration_coord = noiseless_coord + fields_noise_vector;
          }

          ov.out_r_sphere_field += chained_elliptical_remap_select_steps(
              dv.step_count,
              remap,
              remap_min,
              remap_max,
              remap_index_list,
              remap_index_count,
              27.0 * iteration_index,
              calculate_l_angle_bisector_4d(dv.integer_sides,
                                            dv.elliptical_corners,
                                            r_sphere_randomized[0],
                                            r_sphere_randomized[1],
                                            r_sphere_randomized[2],
                                            r_sphere_randomized[3],
                                            iteration_coord));
        }
      }
    }
  }
  else if (dv.mode == "closest") {
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    float min_distance = FLT_MAX;
    float closest_rotation_randomized[7];
    float closest_scale_randomized[4];
    vector4 index_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 index_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 index_noise_vector = dv.noise_fields_strength_1 * index_noise_layer_1 +
                                 dv.noise_fields_strength_2 * index_noise_layer_2;

    for (float k = -scanning_window_size.z; k <= scanning_window_size.z; ++k) {
      for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
        for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
          vector3 iteration_index = vector3(i, j, k) +
                                    vector3(initial_index.x, initial_index.y, initial_index.z);
          float translation_rotation_randomized[7];
          for (int n = 0; n < 7; ++n) {
            translation_rotation_randomized[n] = translation_rotation[n];
          }
          randomize_float_array(translation_rotation_randomized,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                8.0 * iteration_index);
          float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
          randomize_scale(scale_randomized,
                          scale_randomness,
                          scale_index_list,
                          scale_index_count,
                          dv.uniform_scale_randomness,
                          9.0 * iteration_index);

          vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                       j * dv.grid_vector_2 + k * dv.grid_vector_3 +
                                       vector4(translation_rotation_randomized[0],
                                               translation_rotation_randomized[1],
                                               translation_rotation_randomized[2],
                                               translation_rotation_randomized[3]);
          vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                                 translation_rotation_randomized,
                                                 scale_randomized,
                                                 dv.invert_order_of_transformation);
          vector4 iteration_coord;
          if (dv.noise_fragmentation_non_zero) {
            iteration_coord = noiseless_coord +
                              rotate_noise(index_noise_vector, dv.noise_fragmentation, 0.0);
          }
          else {
            iteration_coord = noiseless_coord + index_noise_vector;
          }

          float l_iteration_coord = euclidean_norm(iteration_coord);
          if (l_iteration_coord < min_distance) {
            min_distance = l_iteration_coord;
            ov.out_index_field.x = iteration_index.x;
            ov.out_index_field.y = iteration_index.y;
            ov.out_index_field.z = iteration_index.z;
            ov.out_position_field = iteration_position;
            /* Translation data not needed for subsequent computations. */
            closest_rotation_randomized[4] = translation_rotation_randomized[4];
            closest_rotation_randomized[5] = translation_rotation_randomized[5];
            closest_rotation_randomized[6] = translation_rotation_randomized[6];
            closest_scale_randomized[0] = scale_randomized[0];
            closest_scale_randomized[1] = scale_randomized[1];
            closest_scale_randomized[2] = scale_randomized[2];
            closest_scale_randomized[3] = scale_randomized[3];
          }
        }
      }
    }

    vector4 closest_fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
      else {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
    }
    vector4 closest_fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
      else {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
    }
    vector4 closest_fields_noise_vector = dv.noise_fields_strength_1 *
                                              closest_fields_noise_layer_1 +
                                          dv.noise_fields_strength_2 *
                                              closest_fields_noise_layer_2;
    vector4 closest_coordinates_noise_layer_1 = closest_fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
      else {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
    }
    vector4 closest_coordinates_noise_layer_2 = closest_fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
      else {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            dv.coord - ov.out_position_field,
            7.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));
      }
    }
    vector4 closest_coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                                   closest_coordinates_noise_layer_1 +
                                               dv.noise_coordinates_strength_2 *
                                                   closest_coordinates_noise_layer_2;

    vector4 noiseless_coord = rotate_scale(dv.coord - ov.out_position_field,
                                           closest_rotation_randomized,
                                           closest_scale_randomized,
                                           dv.invert_order_of_transformation);
    if (dv.noise_fragmentation_non_zero) {
      ov.out_r_sphere_coordinates = noiseless_coord +
                                    rotate_noise(closest_coordinates_noise_vector,
                                                 dv.noise_fragmentation,
                                                 7.0 * vector3(ov.out_index_field.x,
                                                               ov.out_index_field.y,
                                                               ov.out_index_field.z));
    }
    else {
      ov.out_r_sphere_coordinates = noiseless_coord + closest_coordinates_noise_vector;
    }

    float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
    randomize_float_array(
        r_sphere_randomized,
        r_sphere_min,
        r_sphere_max,
        r_sphere_index_list,
        r_sphere_index_count,
        5.0 * vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z));

    vector4 out_fields;
    if (dv.noise_fragmentation_non_zero) {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord +
                                               rotate_noise(closest_fields_noise_vector,
                                                            dv.noise_fragmentation,
                                                            7.0 * vector3(ov.out_index_field.x,
                                                                          ov.out_index_field.y,
                                                                          ov.out_index_field.z)));
    }
    else {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord + closest_fields_noise_vector);
    }
    ov.out_r_sphere_field = out_fields.x;
    ov.r_gon_parameter_field = out_fields.y;
    ov.max_unit_parameter_field = out_fields.z;
    ov.segment_id_field = out_fields.w;
  }
  else {
    ov.out_r_sphere_field = 0.0;
    ov.r_gon_parameter_field = 0.0;
    ov.max_unit_parameter_field = 0.0;
    ov.segment_id_field = 0.0;
    ov.out_r_sphere_coordinates = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_position_field = vector4(0.0, 0.0, 0.0, 0.0);
    int first_iteration = 1;

    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;
    vector4 coordinates_noise_layer_1 = fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_layer_2 = fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                           coordinates_noise_layer_1 +
                                       dv.noise_coordinates_strength_2 * coordinates_noise_layer_2;

    for (float k = -scanning_window_size.z; k <= scanning_window_size.z; ++k) {
      for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
        for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
          vector3 iteration_index = vector3(i, j, k) +
                                    vector3(initial_index.x, initial_index.y, initial_index.z);
          float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
          randomize_float_array(r_sphere_randomized,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                5.0 * iteration_index);
          float translation_rotation_randomized[7];
          for (int n = 0; n < 7; ++n) {
            translation_rotation_randomized[n] = translation_rotation[n];
          }
          randomize_float_array(translation_rotation_randomized,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                8.0 * iteration_index);
          float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
          randomize_scale(scale_randomized,
                          scale_randomness,
                          scale_index_list,
                          scale_index_count,
                          dv.uniform_scale_randomness,
                          9.0 * iteration_index);

          vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                       j * dv.grid_vector_2 + k * dv.grid_vector_3 +
                                       vector4(translation_rotation_randomized[0],
                                               translation_rotation_randomized[1],
                                               translation_rotation_randomized[2],
                                               translation_rotation_randomized[3]);
          vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                                 translation_rotation_randomized,
                                                 scale_randomized,
                                                 dv.invert_order_of_transformation);
          vector4 iteration_coord;
          if (dv.noise_fragmentation_non_zero) {
            iteration_coord = noiseless_coord +
                              rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
          }
          else {
            iteration_coord = noiseless_coord + fields_noise_vector;
          }
          vector4 iteration_r_sphere_coordinates;
          if (dv.noise_fragmentation_non_zero) {
            iteration_r_sphere_coordinates = noiseless_coord +
                                             rotate_noise(coordinates_noise_vector,
                                                          dv.noise_fragmentation,
                                                          0.0);
          }
          else {
            iteration_r_sphere_coordinates = noiseless_coord + coordinates_noise_vector;
          }

          vector4 out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                                       dv.calculate_r_gon_parameter_field,
                                                       dv.calculate_max_unit_parameter_field,
                                                       dv.normalize_r_gon_parameter,
                                                       dv.integer_sides,
                                                       dv.elliptical_corners,
                                                       r_sphere_randomized[0],
                                                       r_sphere_randomized[1],
                                                       r_sphere_randomized[2],
                                                       r_sphere_randomized[3],
                                                       iteration_coord);
          float iteration_l_angle_bisector_4d = out_fields.x;
          float iteration_r_gon_parameter = out_fields.y;
          float iteration_max_unit_parameter = out_fields.z;
          float iteration_segment_id = out_fields.w;

          if (dv.smoothness_non_zero) {
            float interpolation_factor = first_iteration ?
                                             1.0 :
                                             smoothstep(0.0,
                                                        1.0,
                                                        0.5 + 0.5 *
                                                                  (ov.out_r_sphere_field -
                                                                   iteration_l_angle_bisector_4d) /
                                                                  dv.smoothness);
            float substraction_factor = dv.smoothness * interpolation_factor *
                                        (1.0 - interpolation_factor);
            ov.out_r_sphere_field = mix(ov.out_r_sphere_field,
                                        iteration_l_angle_bisector_4d,
                                        interpolation_factor) -
                                    substraction_factor;

            ov.r_gon_parameter_field = mix(
                ov.r_gon_parameter_field, iteration_r_gon_parameter, interpolation_factor);
            ov.max_unit_parameter_field = mix(
                ov.max_unit_parameter_field, iteration_max_unit_parameter, interpolation_factor);
            ov.segment_id_field = mix(
                ov.segment_id_field, iteration_segment_id, interpolation_factor);
            ov.out_index_field.x = mix(
                ov.out_index_field.x, iteration_index.x, interpolation_factor);
            ov.out_index_field.y = mix(
                ov.out_index_field.y, iteration_index.y, interpolation_factor);
            ov.out_index_field.z = mix(
                ov.out_index_field.z, iteration_index.z, interpolation_factor);
            ov.out_position_field = mix(
                ov.out_position_field, iteration_position, interpolation_factor);
            ov.out_r_sphere_coordinates = mix(
                ov.out_r_sphere_coordinates, iteration_r_sphere_coordinates, interpolation_factor);
          }
          else if ((iteration_l_angle_bisector_4d < ov.out_r_sphere_field) || first_iteration) {
            ov.out_r_sphere_field = iteration_l_angle_bisector_4d;
            ov.r_gon_parameter_field = iteration_r_gon_parameter;
            ov.max_unit_parameter_field = iteration_max_unit_parameter;
            ov.segment_id_field = iteration_segment_id;
            ov.out_index_field.x = iteration_index.x;
            ov.out_index_field.y = iteration_index.y;
            ov.out_index_field.z = iteration_index.z;
            ov.out_position_field = iteration_position;
            ov.out_r_sphere_coordinates = iteration_r_sphere_coordinates;
          }
          first_iteration = 0;
        }
      }
    }
  }
  return ov;
}

OutVariables raiko_select_mode_4d(DeterministicVariables dv,
                                  float r_sphere[],
                                  float r_sphere_min[],
                                  float r_sphere_max[],
                                  int r_sphere_index_list[],
                                  int r_sphere_index_count,
                                  float translation_rotation[],
                                  float translation_rotation_min[],
                                  float translation_rotation_max[],
                                  int translation_rotation_index_list[],
                                  int translation_rotation_index_count,
                                  float scale[],
                                  float scale_randomness[],
                                  int scale_index_list[],
                                  int scale_index_count,
                                  float remap[],
                                  float remap_min[],
                                  float remap_max[],
                                  int remap_index_list[],
                                  int remap_index_count,
                                  vector4 initial_index,
                                  vector4 initial_position)
{
  float l_grid_vector1 = euclidean_norm(dv.grid_vector_1);
  float l_grid_vector2 = euclidean_norm(dv.grid_vector_2);
  float l_grid_vector3 = euclidean_norm(dv.grid_vector_3);
  float l_grid_vector4 = euclidean_norm(dv.grid_vector_4);
  float l_shortest_grid_vector = min(l_grid_vector1,
                                     min(l_grid_vector2, min(l_grid_vector3, l_grid_vector4)));
  vector4 scanning_window_size = ceil(4.0 * dv.accuracy *
                                      vector4(l_shortest_grid_vector / l_grid_vector1,
                                              l_shortest_grid_vector / l_grid_vector2,
                                              l_shortest_grid_vector / l_grid_vector3,
                                              l_shortest_grid_vector / l_grid_vector4));
  OutVariables ov;
  if (dv.mode == "additive") {
    ov.out_r_sphere_field = 0.0;
    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;

    for (float l = -scanning_window_size.w; l <= scanning_window_size.w; ++l) {
      for (float k = -scanning_window_size.z; k <= scanning_window_size.z; ++k) {
        for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
          for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
            float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
            vector4 iteration_index = vector4(i, j, k, l) + initial_index;
            randomize_float_array(r_sphere_randomized,
                                  r_sphere_min,
                                  r_sphere_max,
                                  r_sphere_index_list,
                                  r_sphere_index_count,
                                  5.0 * iteration_index);
            float translation_rotation_randomized[7];
            for (int n = 0; n < 7; ++n) {
              translation_rotation_randomized[n] = translation_rotation[n];
            }
            randomize_float_array(translation_rotation_randomized,
                                  translation_rotation_min,
                                  translation_rotation_max,
                                  translation_rotation_index_list,
                                  translation_rotation_index_count,
                                  8.0 * iteration_index);
            float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
            randomize_scale(scale_randomized,
                            scale_randomness,
                            scale_index_list,
                            scale_index_count,
                            dv.uniform_scale_randomness,
                            9.0 * iteration_index);

            vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                         j * dv.grid_vector_2 + k * dv.grid_vector_3 +
                                         l * dv.grid_vector_4 +
                                         vector4(translation_rotation_randomized[0],
                                                 translation_rotation_randomized[1],
                                                 translation_rotation_randomized[2],
                                                 translation_rotation_randomized[3]);
            vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                                   translation_rotation_randomized,
                                                   scale_randomized,
                                                   dv.invert_order_of_transformation);
            vector4 iteration_coord;
            if (dv.noise_fragmentation_non_zero) {
              iteration_coord = noiseless_coord +
                                rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
            }
            else {
              iteration_coord = noiseless_coord + fields_noise_vector;
            }

            ov.out_r_sphere_field += chained_elliptical_remap_select_steps(
                dv.step_count,
                remap,
                remap_min,
                remap_max,
                remap_index_list,
                remap_index_count,
                27.0 * iteration_index,
                calculate_l_angle_bisector_4d(dv.integer_sides,
                                              dv.elliptical_corners,
                                              r_sphere_randomized[0],
                                              r_sphere_randomized[1],
                                              r_sphere_randomized[2],
                                              r_sphere_randomized[3],
                                              iteration_coord));
          }
        }
      }
    }
  }
  else if (dv.mode == "closest") {
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    float min_distance = FLT_MAX;
    float closest_rotation_randomized[7];
    float closest_scale_randomized[4];
    vector4 index_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 index_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        index_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 index_noise_vector = dv.noise_fields_strength_1 * index_noise_layer_1 +
                                 dv.noise_fields_strength_2 * index_noise_layer_2;

    for (float l = -scanning_window_size.w; l <= scanning_window_size.w; ++l) {
      for (float k = -scanning_window_size.z; k <= scanning_window_size.z; ++k) {
        for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
          for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
            vector4 iteration_index = vector4(i, j, k, l) + initial_index;
            float translation_rotation_randomized[7];
            for (int n = 0; n < 7; ++n) {
              translation_rotation_randomized[n] = translation_rotation[n];
            }
            randomize_float_array(translation_rotation_randomized,
                                  translation_rotation_min,
                                  translation_rotation_max,
                                  translation_rotation_index_list,
                                  translation_rotation_index_count,
                                  8.0 * iteration_index);
            float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
            randomize_scale(scale_randomized,
                            scale_randomness,
                            scale_index_list,
                            scale_index_count,
                            dv.uniform_scale_randomness,
                            9.0 * iteration_index);

            vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                         j * dv.grid_vector_2 + k * dv.grid_vector_3 +
                                         l * dv.grid_vector_4 +
                                         vector4(translation_rotation_randomized[0],
                                                 translation_rotation_randomized[1],
                                                 translation_rotation_randomized[2],
                                                 translation_rotation_randomized[3]);
            vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                                   translation_rotation_randomized,
                                                   scale_randomized,
                                                   dv.invert_order_of_transformation);
            vector4 iteration_coord;
            if (dv.noise_fragmentation_non_zero) {
              iteration_coord = noiseless_coord +
                                rotate_noise(index_noise_vector, dv.noise_fragmentation, 0.0);
            }
            else {
              iteration_coord = noiseless_coord + index_noise_vector;
            }

            float l_iteration_coord = euclidean_norm(iteration_coord);
            if (l_iteration_coord < min_distance) {
              min_distance = l_iteration_coord;
              ov.out_index_field = iteration_index;
              ov.out_position_field = iteration_position;
              /* Translation data not needed for subsequent computations. */
              closest_rotation_randomized[4] = translation_rotation_randomized[4];
              closest_rotation_randomized[5] = translation_rotation_randomized[5];
              closest_rotation_randomized[6] = translation_rotation_randomized[6];
              closest_scale_randomized[0] = scale_randomized[0];
              closest_scale_randomized[1] = scale_randomized[1];
              closest_scale_randomized[2] = scale_randomized[2];
              closest_scale_randomized[3] = scale_randomized[3];
            }
          }
        }
      }
    }

    vector4 closest_fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field);
      }
      else {
        closest_fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field);
      }
    }
    vector4 closest_fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field);
      }
      else {
        closest_fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field);
      }
    }
    vector4 closest_fields_noise_vector = dv.noise_fields_strength_1 *
                                              closest_fields_noise_layer_1 +
                                          dv.noise_fields_strength_2 *
                                              closest_fields_noise_layer_2;
    vector4 closest_coordinates_noise_layer_1 = closest_fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field);
      }
      else {
        closest_coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field);
      }
    }
    vector4 closest_coordinates_noise_layer_2 = closest_fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(dv.coord - ov.out_position_field,
                         closest_rotation_randomized,
                         closest_scale_randomized,
                         dv.invert_order_of_transformation),
            7.0 * ov.out_index_field);
      }
      else {
        closest_coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv, dv.coord - ov.out_position_field, 7.0 * ov.out_index_field);
      }
    }
    vector4 closest_coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                                   closest_coordinates_noise_layer_1 +
                                               dv.noise_coordinates_strength_2 *
                                                   closest_coordinates_noise_layer_2;

    vector4 noiseless_coord = rotate_scale(dv.coord - ov.out_position_field,
                                           closest_rotation_randomized,
                                           closest_scale_randomized,
                                           dv.invert_order_of_transformation);
    if (dv.noise_fragmentation_non_zero) {
      ov.out_r_sphere_coordinates = noiseless_coord +
                                    rotate_noise(closest_coordinates_noise_vector,
                                                 dv.noise_fragmentation,
                                                 7.0 * ov.out_index_field);
    }
    else {
      ov.out_r_sphere_coordinates = noiseless_coord + closest_coordinates_noise_vector;
    }

    float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
    randomize_float_array(r_sphere_randomized,
                          r_sphere_min,
                          r_sphere_max,
                          r_sphere_index_list,
                          r_sphere_index_count,
                          5.0 * ov.out_index_field);

    vector4 out_fields;
    if (dv.noise_fragmentation_non_zero) {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord +
                                               rotate_noise(closest_fields_noise_vector,
                                                            dv.noise_fragmentation,
                                                            7.0 * ov.out_index_field));
    }
    else {
      out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                           dv.calculate_r_gon_parameter_field,
                                           dv.calculate_max_unit_parameter_field,
                                           dv.normalize_r_gon_parameter,
                                           dv.integer_sides,
                                           dv.elliptical_corners,
                                           r_sphere_randomized[0],
                                           r_sphere_randomized[1],
                                           r_sphere_randomized[2],
                                           r_sphere_randomized[3],
                                           noiseless_coord + closest_fields_noise_vector);
    }
    ov.out_r_sphere_field = out_fields.x;
    ov.r_gon_parameter_field = out_fields.y;
    ov.max_unit_parameter_field = out_fields.z;
    ov.segment_id_field = out_fields.w;
  }
  else {
    ov.out_r_sphere_field = 0.0;
    ov.r_gon_parameter_field = 0.0;
    ov.max_unit_parameter_field = 0.0;
    ov.segment_id_field = 0.0;
    ov.out_r_sphere_coordinates = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_index_field = vector4(0.0, 0.0, 0.0, 0.0);
    ov.out_position_field = vector4(0.0, 0.0, 0.0, 0.0);
    int first_iteration = 1;

    vector4 fields_noise_layer_1 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_1) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 fields_noise_layer_2 = vector4(0.0, 0.0, 0.0, 0.0);
    if (dv.calculate_fields_noise_2) {
      if (dv.transform_fields_noise) {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        fields_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 fields_noise_vector = dv.noise_fields_strength_1 * fields_noise_layer_1 +
                                  dv.noise_fields_strength_2 * fields_noise_layer_2;
    vector4 coordinates_noise_layer_1 = fields_noise_layer_1;
    if (dv.calculate_coordinates_noise_1) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_1 = raiko_noise_fbm_layer_1(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_layer_2 = fields_noise_layer_2;
    if (dv.calculate_coordinates_noise_2) {
      if (dv.transform_coordinates_noise) {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(
            dv,
            rotate_scale(
                dv.coord, translation_rotation, scale, dv.invert_order_of_transformation));
      }
      else {
        coordinates_noise_layer_2 = raiko_noise_fbm_layer_2(dv, dv.coord);
      }
    }
    vector4 coordinates_noise_vector = dv.noise_coordinates_strength_1 *
                                           coordinates_noise_layer_1 +
                                       dv.noise_coordinates_strength_2 * coordinates_noise_layer_2;

    for (float l = -scanning_window_size.w; l <= scanning_window_size.w; ++l) {
      for (float k = -scanning_window_size.z; k <= scanning_window_size.z; ++k) {
        for (float j = -scanning_window_size.y; j <= scanning_window_size.y; ++j) {
          for (float i = -scanning_window_size.x; i <= scanning_window_size.x; ++i) {
            vector4 iteration_index = vector4(i, j, k, l) + initial_index;
            float r_sphere_randomized[4] = {r_sphere[0], r_sphere[1], r_sphere[2], r_sphere[3]};
            randomize_float_array(r_sphere_randomized,
                                  r_sphere_min,
                                  r_sphere_max,
                                  r_sphere_index_list,
                                  r_sphere_index_count,
                                  5.0 * iteration_index);
            float translation_rotation_randomized[7];
            for (int n = 0; n < 7; ++n) {
              translation_rotation_randomized[n] = translation_rotation[n];
            }
            randomize_float_array(translation_rotation_randomized,
                                  translation_rotation_min,
                                  translation_rotation_max,
                                  translation_rotation_index_list,
                                  translation_rotation_index_count,
                                  8.0 * iteration_index);
            float scale_randomized[4] = {scale[0], scale[1], scale[2], scale[3]};
            randomize_scale(scale_randomized,
                            scale_randomness,
                            scale_index_list,
                            scale_index_count,
                            dv.uniform_scale_randomness,
                            9.0 * iteration_index);

            vector4 iteration_position = initial_position + i * dv.grid_vector_1 +
                                         j * dv.grid_vector_2 + k * dv.grid_vector_3 +
                                         l * dv.grid_vector_4 +
                                         vector4(translation_rotation_randomized[0],
                                                 translation_rotation_randomized[1],
                                                 translation_rotation_randomized[2],
                                                 translation_rotation_randomized[3]);
            vector4 noiseless_coord = rotate_scale(dv.coord - iteration_position,
                                                   translation_rotation_randomized,
                                                   scale_randomized,
                                                   dv.invert_order_of_transformation);
            vector4 iteration_coord;
            if (dv.noise_fragmentation_non_zero) {
              iteration_coord = noiseless_coord +
                                rotate_noise(fields_noise_vector, dv.noise_fragmentation, 0.0);
            }
            else {
              iteration_coord = noiseless_coord + fields_noise_vector;
            }
            vector4 iteration_r_sphere_coordinates;
            if (dv.noise_fragmentation_non_zero) {
              iteration_r_sphere_coordinates = noiseless_coord +
                                               rotate_noise(coordinates_noise_vector,
                                                            dv.noise_fragmentation,
                                                            0.0);
            }
            else {
              iteration_r_sphere_coordinates = noiseless_coord + coordinates_noise_vector;
            }

            vector4 out_fields = calculate_out_fields_4d(dv.calculate_r_sphere_field,
                                                         dv.calculate_r_gon_parameter_field,
                                                         dv.calculate_max_unit_parameter_field,
                                                         dv.normalize_r_gon_parameter,
                                                         dv.integer_sides,
                                                         dv.elliptical_corners,
                                                         r_sphere_randomized[0],
                                                         r_sphere_randomized[1],
                                                         r_sphere_randomized[2],
                                                         r_sphere_randomized[3],
                                                         iteration_coord);
            float iteration_l_angle_bisector_4d = out_fields.x;
            float iteration_r_gon_parameter = out_fields.y;
            float iteration_max_unit_parameter = out_fields.z;
            float iteration_segment_id = out_fields.w;

            if (dv.smoothness_non_zero) {
              float interpolation_factor =
                  first_iteration ?
                      1.0 :
                      smoothstep(
                          0.0,
                          1.0,
                          0.5 + 0.5 * (ov.out_r_sphere_field - iteration_l_angle_bisector_4d) /
                                    dv.smoothness);
              float substraction_factor = dv.smoothness * interpolation_factor *
                                          (1.0 - interpolation_factor);
              ov.out_r_sphere_field = mix(ov.out_r_sphere_field,
                                          iteration_l_angle_bisector_4d,
                                          interpolation_factor) -
                                      substraction_factor;

              ov.r_gon_parameter_field = mix(
                  ov.r_gon_parameter_field, iteration_r_gon_parameter, interpolation_factor);
              ov.max_unit_parameter_field = mix(
                  ov.max_unit_parameter_field, iteration_max_unit_parameter, interpolation_factor);
              ov.segment_id_field = mix(
                  ov.segment_id_field, iteration_segment_id, interpolation_factor);
              ov.out_index_field = mix(ov.out_index_field, iteration_index, interpolation_factor);
              ov.out_position_field = mix(
                  ov.out_position_field, iteration_position, interpolation_factor);
              ov.out_r_sphere_coordinates = mix(ov.out_r_sphere_coordinates,
                                                iteration_r_sphere_coordinates,
                                                interpolation_factor);
            }
            else if ((iteration_l_angle_bisector_4d < ov.out_r_sphere_field) || first_iteration) {
              ov.out_r_sphere_field = iteration_l_angle_bisector_4d;
              ov.r_gon_parameter_field = iteration_r_gon_parameter;
              ov.max_unit_parameter_field = iteration_max_unit_parameter;
              ov.segment_id_field = iteration_segment_id;
              ov.out_index_field = iteration_index;
              ov.out_position_field = iteration_position;
              ov.out_r_sphere_coordinates = iteration_r_sphere_coordinates;
            }
            first_iteration = 0;
          }
        }
      }
    }
  }
  return ov;
}

OutVariables raiko_select_grid_dimensions(DeterministicVariables Dv,
                                          float r_sphere[],
                                          float r_sphere_min[],
                                          float r_sphere_max[],
                                          int r_sphere_index_list[],
                                          int r_sphere_index_count,
                                          float translation_rotation[],
                                          float translation_rotation_min[],
                                          float translation_rotation_max[],
                                          int translation_rotation_index_list[],
                                          int translation_rotation_index_count,
                                          float scale[],
                                          float scale_randomness[],
                                          int scale_index_list[],
                                          int scale_index_count,
                                          float remap[],
                                          float remap_min[],
                                          float remap_max[],
                                          int remap_index_list[],
                                          int remap_index_count)
{
  DeterministicVariables dv = Dv;
  OutVariables ov;
  if (dv.grid_dimensions == "0D") {
    ov = raiko_select_mode_0d(dv,
                              r_sphere,
                              r_sphere_min,
                              r_sphere_max,
                              r_sphere_index_list,
                              r_sphere_index_count,
                              translation_rotation,
                              translation_rotation_min,
                              translation_rotation_max,
                              translation_rotation_index_list,
                              translation_rotation_index_count,
                              scale,
                              scale_randomness,
                              scale_index_list,
                              scale_index_count,
                              remap,
                              remap_min,
                              remap_max,
                              remap_index_list,
                              remap_index_count);
  }
  else if (dv.grid_dimensions == "1D") {
    if (dv.grid_vector_1.x != 0.0) {
      dv.grid_vector_1 = vector4(dv.grid_vector_1.x, 0.0, 0.0, 0.0);

      vector4 initial_index = round(vector4(dv.coord.x / dv.grid_vector_1.x, 0.0, 0.0, 0.0));
      vector4 initial_position = initial_index.x * dv.grid_vector_1;

      ov = raiko_select_mode_1d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count,
                                initial_index,
                                initial_position);
    }
    else {
      ov = raiko_select_mode_0d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count);
    }
  }
  else if (dv.grid_dimensions == "2D") {
    float M_det = dv.grid_vector_1.x * dv.grid_vector_2.y -
                  dv.grid_vector_2.x * dv.grid_vector_1.y;
    if (M_det != 0.0) {
      dv.grid_vector_1 = vector4(dv.grid_vector_1.x, dv.grid_vector_1.y, 0.0, 0.0);
      dv.grid_vector_2 = vector4(dv.grid_vector_2.x, dv.grid_vector_2.y, 0.0, 0.0);

      vector2 initial_index_xy = round(
          fc_linear_system_solve_non_singular_2x2(vector2(dv.grid_vector_1.x, dv.grid_vector_1.y),
                                                  vector2(dv.grid_vector_2.x, dv.grid_vector_2.y),
                                                  vector2(dv.coord.x, dv.coord.y),
                                                  M_det));
      vector4 initial_index = vector4(initial_index_xy.x, initial_index_xy.y, 0.0, 0.0);
      vector4 initial_position = initial_index.x * dv.grid_vector_1 +
                                 initial_index.y * dv.grid_vector_2;

      ov = raiko_select_mode_2d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count,
                                initial_index,
                                initial_position);
    }
    else {
      ov = raiko_select_mode_0d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count);
    }
  }
  else if (dv.grid_dimensions == "3D") {
    Fcc_3x3 A_fcc = calculate_Fcc_3x3(
        vector3(dv.grid_vector_1.x, dv.grid_vector_1.y, dv.grid_vector_1.z),
        vector3(dv.grid_vector_2.x, dv.grid_vector_2.y, dv.grid_vector_2.z),
        vector3(dv.grid_vector_3.x, dv.grid_vector_3.y, dv.grid_vector_3.z));
    if (A_fcc.M_det != 0.0) {
      dv.grid_vector_1 = vector4(dv.grid_vector_1.x, dv.grid_vector_1.y, dv.grid_vector_1.z, 0.0);
      dv.grid_vector_2 = vector4(dv.grid_vector_2.x, dv.grid_vector_2.y, dv.grid_vector_2.z, 0.0);
      dv.grid_vector_3 = vector4(dv.grid_vector_3.x, dv.grid_vector_3.y, dv.grid_vector_3.z, 0.0);

      vector3 initial_index_xyz = round(fc_linear_system_solve_non_singular_3x3(
          vector3(dv.grid_vector_1.x, dv.grid_vector_1.y, dv.grid_vector_1.z),
          vector3(dv.grid_vector_2.x, dv.grid_vector_2.y, dv.grid_vector_2.z),
          vector3(dv.grid_vector_3.x, dv.grid_vector_3.y, dv.grid_vector_3.z),
          vector3(dv.coord.x, dv.coord.y, dv.coord.z),
          A_fcc));
      vector4 initial_index = vector4(
          initial_index_xyz.x, initial_index_xyz.y, initial_index_xyz.z, 0.0);
      vector4 initial_position = initial_index.x * dv.grid_vector_1 +
                                 initial_index.y * dv.grid_vector_2 +
                                 initial_index.z * dv.grid_vector_3;

      ov = raiko_select_mode_3d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count,
                                initial_index,
                                initial_position);
    }
    else {
      ov = raiko_select_mode_0d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count);
    }
  }
  else if (dv.grid_dimensions == "4D") {
    Fcc_4x4 A_fcc = calculate_Fcc_4x4(
        dv.grid_vector_1, dv.grid_vector_2, dv.grid_vector_3, dv.grid_vector_4);
    if (A_fcc.M_det != 0.0) {

      vector4 initial_index = round(fc_linear_system_solve_non_singular_4x4(dv.grid_vector_1,
                                                                            dv.grid_vector_2,
                                                                            dv.grid_vector_3,
                                                                            dv.grid_vector_4,
                                                                            dv.coord,
                                                                            A_fcc));
      vector4 initial_position = initial_index.x * dv.grid_vector_1 +
                                 initial_index.y * dv.grid_vector_2 +
                                 initial_index.z * dv.grid_vector_3 +
                                 initial_index.w * dv.grid_vector_4;

      ov = raiko_select_mode_4d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count,
                                initial_index,
                                initial_position);
    }
    else {
      ov = raiko_select_mode_0d(dv,
                                r_sphere,
                                r_sphere_min,
                                r_sphere_max,
                                r_sphere_index_list,
                                r_sphere_index_count,
                                translation_rotation,
                                translation_rotation_min,
                                translation_rotation_max,
                                translation_rotation_index_list,
                                translation_rotation_index_count,
                                scale,
                                scale_randomness,
                                scale_index_list,
                                scale_index_count,
                                remap,
                                remap_min,
                                remap_max,
                                remap_index_list,
                                remap_index_count);
    }
  }
  return ov;
}

shader node_raiko_texture(int use_mapping = 0,
                          matrix mapping = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                          string mode = "additive",
                          int normalize_r_gon_parameter = 0,
                          int integer_sides = 0,
                          int elliptical_corners = 0,
                          int invert_order_of_transformation = 0,
                          int transform_fields_noise = 1,
                          int transform_coordinates_noise = 1,
                          int uniform_scale_randomness = 1,
                          string grid_dimensions = "2D",
                          string step_count = "1_step",
                          vector3 Vector = P,
                          float W = 0.0,
                          float Accuracy = 0.1,
                          float Scale = 1.0,
                          float Smoothness = 1.0,
                          float R_gonSides = 0.0,
                          float R_gonRoundness = 5.0,
                          float R_gonExponent = 2.0,
                          float SphereExponent = 2.0,
                          float R_gonSidesRandomness = 0.0,
                          float R_gonRoundnessRandomness = 5.0,
                          float R_gonExponentRandomness = 2.0,
                          float SphereExponentRandomness = 2.0,
                          vector3 RotationTransform = vector3(0.0, 0.0, 0.0),
                          vector3 ScaleTransform = vector3(1.0, 1.0, 1.0),
                          float ScaleTransformW = 1.0,
                          vector3 RotationTransformRandomness = vector3(0.0, 0.0, 0.0),
                          vector3 ScaleTransformRandomness = vector3(1.0, 1.0, 1.0),
                          float ScaleTransformWRandomness = 1.0,
                          float Fragmentation = 0.0,
                          float FieldsStrength1 = 0.0,
                          float CoordinatesStrength1 = 0.0,
                          float Scale1 = 5.0,
                          float Detail1 = 2.0,
                          float Roughness1 = 0.5,
                          float Lacunarity1 = 2.0,
                          float FieldsStrength2 = 0.0,
                          float CoordinatesStrength2 = 0.0,
                          float Scale2 = 5.0,
                          float Detail2 = 2.0,
                          float Roughness2 = 0.5,
                          float Lacunarity2 = 2.0,
                          vector3 TransformRotationRandomness = vector3(0.0, 0.0, 0.0),
                          vector3 TransformScaleRandomness = vector3(0.0, 0.0, 0.0),
                          float TransformScaleWRandomness = 0.0,
                          vector3 GridVector1 = vector3(1.0, 0.0, 0.0),
                          float GridVectorW1 = 0.0,
                          vector3 GridVector2 = vector3(0.0, 1.0, 0.0),
                          float GridVectorW2 = 0.0,
                          vector3 GridVector3 = vector3(0.0, 0.0, 1.0),
                          float GridVectorW3 = 0.0,
                          vector3 GridVector4 = vector3(0.0, 0.0, 0.0),
                          float GridVectorW4 = 1.0,
                          vector3 GridPointsTranslationRandomness = vector3(0.0, 0.0, 0.0),
                          float GridPointsTranslationWRandomness = 0.0,
                          float StepCenter1 = 0.1875,
                          float StepWidth1 = 0.125,
                          float StepValue1 = 0.5,
                          float EllipseHeight1 = 0.5,
                          float EllipseWidth1 = 0.5,
                          float InflectionPoint1 = 0.5,
                          float StepCenter2 = 0.34375,
                          float StepWidth2 = 0.0625,
                          float StepValue2 = 0.25,
                          float EllipseHeight2 = 0.5,
                          float EllipseWidth2 = 0.5,
                          float InflectionPoint2 = 0.5,
                          float StepCenter3 = 421875,
                          float StepWidth3 = 0.03125,
                          float StepValue3 = 0.125,
                          float EllipseHeight3 = 0.5,
                          float EllipseWidth3 = 0.5,
                          float InflectionPoint3 = 0.5,
                          float StepCenter4 = 0.4609375,
                          float StepWidth4 = 0.015625,
                          float StepValue4 = 0.0625,
                          float EllipseHeight4 = 0.5,
                          float EllipseWidth4 = 0.5,
                          float InflectionPoint4 = 0.5,
                          float StepCenterRandomness1 = 0.0,
                          float StepWidthRandomness1 = 0.0,
                          float StepValueRandomness1 = 0.0,
                          float EllipseHeightRandomness1 = 0.0,
                          float EllipseWidthRandomness1 = 0.0,
                          float InflectionPointRandomness1 = 0.0,
                          float StepCenterRandomness2 = 0.0,
                          float StepWidthRandomness2 = 0.0,
                          float StepValueRandomness2 = 0.0,
                          float EllipseHeightRandomness2 = 0.0,
                          float EllipseWidthRandomness2 = 0.0,
                          float InflectionPointRandomness2 = 0.0,
                          float StepCenterRandomness3 = 0.0,
                          float StepWidthRandomness3 = 0.0,
                          float StepValueRandomness3 = 0.0,
                          float EllipseHeightRandomness3 = 0.0,
                          float EllipseWidthRandomness3 = 0.0,
                          float InflectionPointRandomness3 = 0.0,
                          float StepCenterRandomness4 = 0.0,
                          float StepWidthRandomness4 = 0.0,
                          float StepValueRandomness4 = 0.0,
                          float EllipseHeightRandomness4 = 0.0,
                          float EllipseWidthRandomness4 = 0.0,
                          float InflectionPointRandomness4 = 0.0,
                          output float R_sphereField = 0.0,
                          output float R_gonParameterField = 0.0,
                          output float MaxUnitParameterField = 0.0,
                          output float SegmentIDField = 0.0,
                          output vector3 IndexField = vector3(0.0, 0.0, 0.0),
                          output float IndexFieldW = 0.0,
                          output vector3 PositionField = vector3(0.0, 0.0, 0.0),
                          output float PositionFieldW = 0.0,
                          output vector3 R_sphereCoordinates = vector3(0.0, 0.0, 0.0),
                          output float R_sphereCoordinatesW = 0.0, )
{
  DeterministicVariables dv;

  /* isconnected() returns 2 when output socket is connected. */
  dv.calculate_r_sphere_field = int(
      (isconnected(R_sphereField) != 0) || (isconnected(R_gonParameterField) != 0) ||
      (isconnected(MaxUnitParameterField) != 0) || (mode != "closest"));
  dv.calculate_r_gon_parameter_field = int(isconnected(R_gonParameterField) != 0);
  dv.calculate_max_unit_parameter_field = int(isconnected(MaxUnitParameterField) != 0);
  dv.calculate_coordinates_outputs = int(
      ((isconnected(R_sphereCoordinates) != 0) || (isconnected(R_sphereCoordinatesW) != 0)) &&
      (mode != "additive"));

  dv.mode = mode;
  dv.normalize_r_gon_parameter = int((isconnected(R_gonParameterField) != 0.0) &&
                                     (normalize_r_gon_parameter != 0));
  dv.integer_sides = integer_sides;
  dv.elliptical_corners = elliptical_corners;
  dv.invert_order_of_transformation = invert_order_of_transformation;
  dv.transform_fields_noise = transform_fields_noise;
  dv.transform_coordinates_noise = transform_coordinates_noise;
  dv.uniform_scale_randomness = uniform_scale_randomness;
  dv.grid_dimensions = grid_dimensions;
  dv.step_count = step_count;

  dv.accuracy = Accuracy;
  dv.scale = Scale;
  dv.coord = dv.scale * vector4(Vector.x, Vector.y, Vector.z, W);
  dv.smoothness = Smoothness;
  dv.smoothness_non_zero = dv.smoothness != 0.0;
  float r_sphere[4] = {R_gonSides, R_gonRoundness, R_gonExponent, SphereExponent};
  float r_sphere_min[4];
  float r_sphere_max[4];
  int r_sphere_index_list[4];
  int r_sphere_index_count;
  int index_count = 0;
  if (R_gonSidesRandomness != 0.0) {
    r_sphere_min[index_count] = max(r_sphere[0] - R_gonSidesRandomness, 2.0);
    r_sphere_max[index_count] = max(r_sphere[0] + R_gonSidesRandomness, 2.0);
    r_sphere_index_list[index_count] = 0;
    ++index_count;
  }
  if (R_gonRoundnessRandomness != 0.0) {
    r_sphere_min[index_count] = clamp(r_sphere[1] - R_gonRoundnessRandomness, 0.0, 1.0);
    r_sphere_max[index_count] = clamp(r_sphere[1] + R_gonRoundnessRandomness, 0.0, 1.0);
    r_sphere_index_list[index_count] = 1;
    ++index_count;
  }
  if (R_gonExponentRandomness != 0.0) {
    r_sphere_min[index_count] = max(r_sphere[2] - R_gonExponentRandomness, 0.0);
    r_sphere_max[index_count] = max(r_sphere[2] + R_gonExponentRandomness, 0.0);
    r_sphere_index_list[index_count] = 2;
    ++index_count;
  }
  if (SphereExponentRandomness != 0.0) {
    r_sphere_min[index_count] = max(r_sphere[3] - SphereExponentRandomness, 0.0);
    r_sphere_max[index_count] = max(r_sphere[3] + SphereExponentRandomness, 0.0);
    r_sphere_index_list[index_count] = 3;
    ++index_count;
  }
  r_sphere_index_count = index_count;
  float translation_rotation[7] = {
      0.0, 0.0, 0.0, 0.0, RotationTransform.x, RotationTransform.y, RotationTransform.z};
  float translation_rotation_min[7];
  float translation_rotation_max[7];
  int translation_rotation_index_list[7];
  int translation_rotation_index_count;
  index_count = 0;
  if (GridPointsTranslationRandomness.x != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[0] -
                                            GridPointsTranslationRandomness.x;
    translation_rotation_max[index_count] = translation_rotation[0] +
                                            GridPointsTranslationRandomness.x;
    translation_rotation_index_list[index_count] = 0;
    ++index_count;
  }
  if (GridPointsTranslationRandomness.y != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[1] -
                                            GridPointsTranslationRandomness.y;
    translation_rotation_max[index_count] = translation_rotation[1] +
                                            GridPointsTranslationRandomness.y;
    translation_rotation_index_list[index_count] = 1;
    ++index_count;
  }
  if (GridPointsTranslationRandomness.z != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[2] -
                                            GridPointsTranslationRandomness.z;
    translation_rotation_max[index_count] = translation_rotation[2] +
                                            GridPointsTranslationRandomness.z;
    translation_rotation_index_list[index_count] = 2;
    ++index_count;
  }
  if (GridPointsTranslationWRandomness != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[3] -
                                            GridPointsTranslationWRandomness;
    translation_rotation_max[index_count] = translation_rotation[3] +
                                            GridPointsTranslationWRandomness;
    translation_rotation_index_list[index_count] = 3;
    ++index_count;
  }
  if (RotationTransformRandomness.x != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[4] -
                                            RotationTransformRandomness.x;
    translation_rotation_max[index_count] = translation_rotation[4] +
                                            RotationTransformRandomness.x;
    translation_rotation_index_list[index_count] = 4;
    ++index_count;
  }
  if (RotationTransformRandomness.y != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[5] -
                                            RotationTransformRandomness.y;
    translation_rotation_max[index_count] = translation_rotation[5] +
                                            RotationTransformRandomness.y;
    translation_rotation_index_list[index_count] = 5;
    ++index_count;
  }
  if (RotationTransformRandomness.z != 0.0) {
    translation_rotation_min[index_count] = translation_rotation[6] -
                                            RotationTransformRandomness.z;
    translation_rotation_max[index_count] = translation_rotation[6] +
                                            RotationTransformRandomness.z;
    translation_rotation_index_list[index_count] = 6;
    ++index_count;
  }
  translation_rotation_index_count = index_count;
  float scale[4] = {ScaleTransform.x, ScaleTransform.y, ScaleTransform.z, ScaleTransformW};
  float scale_randomness[4];
  int scale_index_list[4];
  int scale_index_count;
  index_count = 0;
  if (!dv.uniform_scale_randomness) {
    if (ScaleTransformRandomness.x != 0.0) {
      scale_randomness[index_count] = ScaleTransformRandomness.x;
      scale_index_list[index_count] = 0;
      ++index_count;
    }
    if (ScaleTransformRandomness.y != 0.0) {
      scale_randomness[index_count] = ScaleTransformRandomness.y;
      scale_index_list[index_count] = 1;
      ++index_count;
    }
    if (ScaleTransformRandomness.z != 0.0) {
      scale_randomness[index_count] = ScaleTransformRandomness.z;
      scale_index_list[index_count] = 2;
      ++index_count;
    }
  }
  if (ScaleTransformWRandomness != 0.0) {
    scale_randomness[index_count] = ScaleTransformWRandomness;
    scale_index_list[index_count] = 3;
    ++index_count;
  }
  scale_index_count = index_count;
  dv.noise_fragmentation = Fragmentation;
  dv.noise_fields_strength_1 = FieldsStrength1;
  dv.noise_coordinates_strength_1 = CoordinatesStrength1 * float(dv.calculate_coordinates_outputs);
  dv.noise_scale_1 = Scale1;
  dv.noise_detail_1 = Detail1;
  dv.noise_roughness_1 = Roughness1;
  dv.noise_lacunarity_1 = Lacunarity1;
  dv.noise_fields_strength_2 = FieldsStrength2;
  dv.noise_coordinates_strength_2 = CoordinatesStrength2 * float(dv.calculate_coordinates_outputs);
  dv.noise_scale_2 = Scale2;
  dv.noise_detail_2 = Detail2;
  dv.noise_roughness_2 = Roughness2;
  dv.noise_lacunarity_2 = Lacunarity2;
  dv.noise_fragmentation_non_zero = int(dv.noise_fragmentation != 0.0);
  dv.calculate_fields_noise_1 = int(dv.noise_fields_strength_1 != 0.0);
  dv.calculate_fields_noise_2 = int(dv.noise_fields_strength_2 != 0.0);
  dv.calculate_coordinates_noise_1 = int(
      (dv.noise_coordinates_strength_1 != 0.0) &&
      (!(dv.calculate_fields_noise_1 &&
         (dv.transform_fields_noise == dv.transform_coordinates_noise))));
  dv.calculate_coordinates_noise_2 = int(
      (dv.noise_coordinates_strength_2 != 0.0) &&
      (!(dv.calculate_fields_noise_2 &&
         (dv.transform_fields_noise == dv.transform_coordinates_noise))));
  if (dv.grid_dimensions == "1D") {
    dv.grid_vector_1.x = GridVectorW1;
  }
  else {
    dv.grid_vector_1 = vector4(GridVector1.x, GridVector1.y, GridVector1.z, GridVectorW1);
    dv.grid_vector_2 = vector4(GridVector2.x, GridVector2.y, GridVector2.z, GridVectorW2);
    dv.grid_vector_3 = vector4(GridVector3.x, GridVector3.y, GridVector3.z, GridVectorW3);
    dv.grid_vector_4 = vector4(GridVector4.x, GridVector4.y, GridVector4.z, GridVectorW4);
  }
  float remap[24];
  float remap_min[24];
  float remap_max[24];
  int remap_index_list[24];
  int remap_index_count;
  index_count = 0;
  if (dv.mode == "additive") {
    if (dv.step_count == "4_steps") {
      ASSIGN_REMAP_INPUTS(1, 0, 1, 2, 3, 4, 5)
      ASSIGN_REMAP_INPUTS(2, 6, 7, 8, 9, 10, 11)
      ASSIGN_REMAP_INPUTS(3, 12, 13, 14, 15, 16, 17)
      ASSIGN_REMAP_INPUTS(4, 18, 19, 20, 21, 22, 23)
    }
    else if (dv.step_count == "3_steps") {
      ASSIGN_REMAP_INPUTS(1, 0, 1, 2, 3, 4, 5)
      ASSIGN_REMAP_INPUTS(2, 6, 7, 8, 9, 10, 11)
      ASSIGN_REMAP_INPUTS(3, 12, 13, 14, 15, 16, 17)
    }
    else if (dv.step_count == "2_steps") {
      ASSIGN_REMAP_INPUTS(1, 0, 1, 2, 3, 4, 5)
      ASSIGN_REMAP_INPUTS(2, 6, 7, 8, 9, 10, 11)
    }
    else {
      ASSIGN_REMAP_INPUTS(1, 0, 1, 2, 3, 4, 5)
    }
  }
  remap_index_count = index_count;

  OutVariables ov = raiko_select_grid_dimensions(dv,
                                                 r_sphere,
                                                 r_sphere_min,
                                                 r_sphere_max,
                                                 r_sphere_index_list,
                                                 r_sphere_index_count,
                                                 translation_rotation,
                                                 translation_rotation_min,
                                                 translation_rotation_max,
                                                 translation_rotation_index_list,
                                                 translation_rotation_index_count,
                                                 scale,
                                                 scale_randomness,
                                                 scale_index_list,
                                                 scale_index_count,
                                                 remap,
                                                 remap_min,
                                                 remap_max,
                                                 remap_index_list,
                                                 remap_index_count);

  R_sphereField = ov.out_r_sphere_field;
  R_gonParameterField = ov.r_gon_parameter_field;
  MaxUnitParameterField = ov.max_unit_parameter_field;
  SegmentIDField = ov.segment_id_field;
  if (dv.grid_dimensions == "1D") {
    IndexFieldW = ov.out_index_field.x;
  }
  else {
    IndexField = vector3(ov.out_index_field.x, ov.out_index_field.y, ov.out_index_field.z);
    IndexFieldW = ov.out_index_field.w;
  }
  PositionField = vector3(
      ov.out_position_field.x, ov.out_position_field.y, ov.out_position_field.z);
  PositionFieldW = ov.out_position_field.w;
  R_sphereCoordinates = vector3(
      ov.out_r_sphere_coordinates.x, ov.out_r_sphere_coordinates.y, ov.out_r_sphere_coordinates.z);
  R_sphereCoordinatesW = ov.out_r_sphere_coordinates.w;
}
